<!DOCTYPE HoGBOT>
<HoGSettings>
    <Healer>
        <HealRules>
            <HealRule label="HealRule">
                <HealthRange max="80" min="25" type="%"></HealthRange>
                <ManaRange max="100" min="0" type="%"></ManaRange>
                <Method>Wound Cleansing</Method>
                <ExtraCondition></ExtraCondition>
            </HealRule>
            <HealRule label="">
                <HealthRange max="100" min="0" type="%"></HealthRange>
                <ManaRange max="40" min="0" type="%"></ManaRange>
                <Method>Mana Potion</Method>
                <ExtraCondition></ExtraCondition>
            </HealRule>
            <HealRule label="">
                <HealthRange max="25" min="0" type="%"></HealthRange>
                <ManaRange max="100" min="0" type="%"></ManaRange>
                <Method>Health Potion</Method>
                <ExtraCondition></ExtraCondition>
            </HealRule>
        </HealRules>
        <HealFriends/>
    </Healer>
    <CaveBot>
        <Waypoints>
            <Waypoint action="" label="depo" type="Node" x="32919" y="31478" z="7"/>
            <Waypoint action="--- depositer&#xa;&#xa;--[[&#xa;    This file is part of the Tibia HoGBot (https://github.com/TibiaHoGBot/HoGBot-Library).&#xa;    Copyright (c) 2023 TIBIAHOGBOT LLC.&#xa;&#xa;    This program is free software: you can redistribute it and/or modify&#xa;    it under the terms of the GNU General Public License as published by&#xa;    the Free Software Foundation, version 3.&#xa;&#xa;    This program is distributed in the hope that it will be useful, but&#xa;    WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU&#xa;    General Public License for more details.&#xa;&#xa;    You should have received a copy of the GNU General Public License&#xa;    along with this program. If not, see &lt;http://www.gnu.org/licenses/>.&#xa;--]]&#xa;--[[&#xa;        Constants&#xa;--]]&#xa;CREATURE_TYPE_PLAYER = 0&#xa;CREATURE_TYPE_MONSTER = 1&#xa;CREATURE_TYPE_NPC = 2&#xa;CREATURE_TYPE_PLAYER_SUMMON = 3&#xa;CREATURE_TYPE_OTHER_SUMMON = 4&#xa;&#xa;DIRECTION_NORTH = 0&#xa;DIRECTION_EAST = 1&#xa;DIRECTION_SOUTH = 2&#xa;DIRECTION_WEST = 3&#xa;&#xa;INVENTORY_HELMET = 1&#xa;INVENTORY_NECKLACE = 2&#xa;INVENTORY_BACKPACK = 3&#xa;INVENTORY_ARMOR = 4&#xa;INVENTORY_SHIELD = 5&#xa;INVENTORY_WEAPON = 6&#xa;INVENTORY_LEGS = 7&#xa;INVENTORY_SHOES = 8&#xa;INVENTORY_RING = 9&#xa;INVENTORY_TRINKET = 10&#xa;&#xa;ITEM_BANK = 1&#xa;ITEM_CLIP = 2&#xa;ITEM_BOTTOM = 3&#xa;ITEM_TOP = 4&#xa;ITEM_CONTAINER = 5&#xa;ITEM_CUMULATIVE = 6&#xa;ITEM_USABLE = 7&#xa;ITEM_FORCEUSE = 8&#xa;ITEM_MULTIUSE = 9&#xa;ITEM_LIQUIDPOOL = 12&#xa;ITEM_UNPASS = 13&#xa;ITEM_UNMOVE = 14&#xa;ITEM_UNSIGHT = 15&#xa;ITEM_AVOID = 16&#xa;ITEM_NO_MOVE_ANIMATION = 17&#xa;ITEM_TAKE = 18&#xa;ITEM_LIQUID_CONTAINER = 19&#xa;ITEM_HANG = 20&#xa;ITEM_HOOK = 21&#xa;ITEM_ROTATE = 22&#xa;ITEM_LIGHT = 23&#xa;ITEM_DONT_HIDE = 24&#xa;ITEM_TRANSLUCENT = 25&#xa;ITEM_SHIFT = 26&#xa;ITEM_HEIGHT = 27&#xa;ITEM_LYING_OBJECT = 28&#xa;ITEM_ANIMATE_ALWAYS = 29&#xa;ITEM_AUTOMAP = 30&#xa;ITEM_LENS_HELP = 31&#xa;ITEM_FULLBANK = 32&#xa;ITEM_IGNORE_LOOK = 33&#xa;ITEM_CLOTHES = 34&#xa;ITEM_DEFAULT_ACTION = 35&#xa;ITEM_MARKET = 36&#xa;ITEM_WRAP = 37&#xa;ITEM_UNWRAP = 38&#xa;ITEM_TOP_EFFECT = 39&#xa;ITEM_NPC_SALE_DATA = 40&#xa;ITEM_CHANGED_TO_EXPIRE = 41&#xa;ITEM_CORPSE = 42&#xa;ITEM_PLAYER_CORPSE = 43&#xa;ITEM_CYCLOPEDIA_ITEM = 44&#xa;ITEM_AMMO = 45&#xa;ITEM_SHOW_OFF_SOCKET = 46&#xa;ITEM_REPORTABLE = 47&#xa;ITEM_UPGRADE_CLASSIFICATION = 48&#xa;ITEM_REVERSE_ADDONS_EAST = 49&#xa;ITEM_REVERSE_ADDONS_WEST = 50&#xa;ITEM_REVERSE_ADDONS_SOUTH = 51&#xa;ITEM_REVERSE_ADDONS_NORTH = 52&#xa;ITEM_WEAROUT = 53&#xa;ITEM_CLOCK_EXPIRE = 54&#xa;ITEM_EXPIRE = 55&#xa;ITEM_EXPIRE_STOP = 56&#xa;ITEM_DECO_ITEM_KIT = 57&#xa;&#xa;MESSAGE_TYPE_SAY = 1&#xa;MESSAGE_TYPE_WHISPER = 2&#xa;MESSAGE_TYPE_YELL = 3&#xa;MESSAGE_TYPE_NPC_TO = 12&#xa;MESSAGE_TYPE_LOOK = 22&#xa;MESSAGE_TYPE_STATUS = 30&#xa;MESSAGE_TYPE_LOOT = 31&#xa;&#xa;PLAYER_FLAGS_POISON = 1&#xa;PLAYER_FLAGS_FIRE = 2&#xa;PLAYER_FLAGS_ENERGY = 4&#xa;PLAYER_FLAGS_DRUNK = 8&#xa;PLAYER_FLAGS_MANA_SHIELD = 16&#xa;PLAYER_FLAGS_PARALYSED = 32&#xa;PLAYER_FLAGS_HASTE = 64&#xa;PLAYER_FLAGS_BATTLE = 128&#xa;PLAYER_FLAGS_DROWNING = 256&#xa;PLAYER_FLAGS_FREEZING = 512&#xa;PLAYER_FLAGS_DAZZLING = 1024&#xa;PLAYER_FLAGS_CURSED = 2048&#xa;PLAYER_FLAGS_STRENGTHENED = 4096&#xa;PLAYER_FLAGS_RED_SWORDS = 8192&#xa;PLAYER_FLAGS_PROTECTION_ZONE = 16384&#xa;PLAYER_FLAGS_BLEEDING = 32768&#xa;PLAYER_FLAGS_LESSER_HEX = 65536&#xa;PLAYER_FLAGS_INTENSE_HEX = 131072&#xa;PLAYER_FLAGS_GREATER_HEX = 262144&#xa;PLAYER_FLAGS_ROOTED = 524288&#xa;PLAYER_FLAGS_FEARED = 1048576&#xa;PLAYER_FLAGS_GOSHNAR_1 = 2097152&#xa;PLAYER_FLAGS_GOSHNAR_2 = 4194304&#xa;PLAYER_FLAGS_GOSHNAR_3 = 8388608&#xa;PLAYER_FLAGS_GOSHNAR_4 = 16777216&#xa;PLAYER_FLAGS_GOSHNAR_5 = 33554432&#xa;PLAYER_FLAGS_MANA_SHIELD_NEW = 67108864&#xa;&#xa;STEP_DIRECTION_EAST = 1&#xa;STEP_DIRECTION_NORTH_EAST = 2&#xa;STEP_DIRECTION_NORTH = 3&#xa;STEP_DIRECTION_NORTH_WEST = 4&#xa;STEP_DIRECTION_WEST = 5&#xa;STEP_DIRECTION_SOUTH_WEST = 6&#xa;STEP_DIRECTION_SOUTH = 7&#xa;STEP_DIRECTION_SOUTH_EAST = 8&#xa;&#xa;TILE_DEPOT_SWITCH = 31501&#xa;&#xa;local CLOSED_DOOR_IDS = {&#xa;    1628,&#xa;    1629,&#xa;    1631,&#xa;    1632,&#xa;    1638,&#xa;    1640,&#xa;    1642,&#xa;    1644,&#xa;    1646,&#xa;    1648,&#xa;    1650,&#xa;    1651,&#xa;    1653,&#xa;    1654,&#xa;    1656,&#xa;    1658,&#xa;    1660,&#xa;    1662,&#xa;    1664,&#xa;    1666,&#xa;    1668,&#xa;    1669,&#xa;    1671,&#xa;    1672,&#xa;    1674,&#xa;    1676,&#xa;    1678,&#xa;    1680,&#xa;    1682,&#xa;    1683,&#xa;    1685,&#xa;    1687,&#xa;    1689,&#xa;    1691,&#xa;    1692,&#xa;    1694,&#xa;    1696,&#xa;    1698,&#xa;    4912,&#xa;    4913,&#xa;    5006,&#xa;    5007,&#xa;    5082,&#xa;    5084,&#xa;    5097,&#xa;    5098,&#xa;    5100,&#xa;    5102,&#xa;    5104,&#xa;    5106,&#xa;    5107,&#xa;    5109,&#xa;    5111,&#xa;    5113,&#xa;    5115,&#xa;    5116,&#xa;    5118,&#xa;    5120,&#xa;    5122,&#xa;    5124,&#xa;    5125,&#xa;    5127,&#xa;    5129,&#xa;    5131,&#xa;    5133,&#xa;    5134,&#xa;    5136,&#xa;    5137,&#xa;    5139,&#xa;    5140,&#xa;    5142,&#xa;    5143,&#xa;    5277,&#xa;    5278,&#xa;    5280,&#xa;    5281,&#xa;    5282,&#xa;    5285,&#xa;    5287,&#xa;    5289,&#xa;    5291,&#xa;    5293,&#xa;    5302,&#xa;    5303,&#xa;    5514,&#xa;    5516,&#xa;    5732,&#xa;    5735,&#xa;    5745,&#xa;    5749,&#xa;    6191,&#xa;    6192,&#xa;    6194,&#xa;    6195,&#xa;    6197,&#xa;    6199,&#xa;    6201,&#xa;    6203,&#xa;    6205,&#xa;    6207,&#xa;    6248,&#xa;    6249,&#xa;    6251,&#xa;    6252,&#xa;    6254,&#xa;    6258,&#xa;    6260,&#xa;    6262,&#xa;    6264,&#xa;    6435,&#xa;    6436,&#xa;    6439,&#xa;    6440,&#xa;    6443,&#xa;    6444,&#xa;    6449,&#xa;    6450,&#xa;    6453,&#xa;    6454,&#xa;    6457,&#xa;    6458,&#xa;    6461,&#xa;    6462,&#xa;    6465,&#xa;    6466,&#xa;    6469,&#xa;    6470,&#xa;    6788,&#xa;    6789,&#xa;    6891,&#xa;    6892,&#xa;    6894,&#xa;    6896,&#xa;    6898,&#xa;    6900,&#xa;    6901,&#xa;    6903,&#xa;    6905,&#xa;    6907,&#xa;    7027,&#xa;    7028,&#xa;    7033,&#xa;    7034,&#xa;    7036,&#xa;    7038,&#xa;    7040,&#xa;    7042,&#xa;    7043,&#xa;    7045,&#xa;    7047,&#xa;    7049,&#xa;    7051,&#xa;    7052,&#xa;    7711,&#xa;    7712,&#xa;    7714,&#xa;    7715,&#xa;    7717,&#xa;    7719,&#xa;    7721,&#xa;    7723,&#xa;    7725,&#xa;    7727,&#xa;    7868,&#xa;    7941,&#xa;    8249,&#xa;    8250,&#xa;    8252,&#xa;    8253,&#xa;    8255,&#xa;    8257,&#xa;    8258,&#xa;    8261,&#xa;    8263,&#xa;    8265,&#xa;    8351,&#xa;    8352,&#xa;    8354,&#xa;    8355,&#xa;    8357,&#xa;    8359,&#xa;    8361,&#xa;    8363,&#xa;    8365,&#xa;    8367,&#xa;    9347,&#xa;    9348,&#xa;    9351,&#xa;    9352,&#xa;    9354,&#xa;    9355,&#xa;    9357,&#xa;    9359,&#xa;    9361,&#xa;    9363,&#xa;    9365,&#xa;    9367,&#xa;    9551,&#xa;    9552,&#xa;    9554,&#xa;    9556,&#xa;    9558,&#xa;    9560,&#xa;    9561,&#xa;    9563,&#xa;    9565,&#xa;    9567,&#xa;    9571,&#xa;    9572,&#xa;    9858,&#xa;    9859,&#xa;    9863,&#xa;    9865,&#xa;    9867,&#xa;    9868,&#xa;    9872,&#xa;    9874,&#xa;    10147,&#xa;    10149,&#xa;    10151,&#xa;    10153,&#xa;    10155,&#xa;    10157,&#xa;    10520,&#xa;    10521,&#xa;    11232,&#xa;    11233,&#xa;    11237,&#xa;    11239,&#xa;    11241,&#xa;    11242,&#xa;    11246,&#xa;    11248,&#xa;    11705,&#xa;    11714,&#xa;    17560,&#xa;    17561,&#xa;    17563,&#xa;    17565,&#xa;    17567,&#xa;    17569,&#xa;    17570,&#xa;    17572,&#xa;    17574,&#xa;    17576,&#xa;    17700,&#xa;    17701,&#xa;    17703,&#xa;    17705,&#xa;    17707,&#xa;    17709,&#xa;    17710,&#xa;    17712,&#xa;    17714,&#xa;    17716,&#xa;    20443,&#xa;    20444,&#xa;    20446,&#xa;    20448,&#xa;    20450,&#xa;    20452,&#xa;    20453,&#xa;    20455,&#xa;    20457,&#xa;    20459&#xa;}&#xa;local OPENED_DOOR_IDS = {&#xa;    1630,&#xa;    1633,&#xa;    1639,&#xa;    1641,&#xa;    1643,&#xa;    1645,&#xa;    1647,&#xa;    1649,&#xa;    1652,&#xa;    1655,&#xa;    1657,&#xa;    1659,&#xa;    1661,&#xa;    1663,&#xa;    1665,&#xa;    1667,&#xa;    1670,&#xa;    1673,&#xa;    1675,&#xa;    1677,&#xa;    1679,&#xa;    1681,&#xa;    1684,&#xa;    1686,&#xa;    1688,&#xa;    1690,&#xa;    1693,&#xa;    1695,&#xa;    1697,&#xa;    1699,&#xa;    2178,&#xa;    2180,&#xa;    4911,&#xa;    4914,&#xa;    5083,&#xa;    5085,&#xa;    5099,&#xa;    5101,&#xa;    5103,&#xa;    5105,&#xa;    5108,&#xa;    5110,&#xa;    5112,&#xa;    5114,&#xa;    5117,&#xa;    5117,&#xa;    5119,&#xa;    5121,&#xa;    5123,&#xa;    5126,&#xa;    5128,&#xa;    5130,&#xa;    5132,&#xa;    5135,&#xa;    5138,&#xa;    5141,&#xa;    5144,&#xa;    5279,&#xa;    5282,&#xa;    5284,&#xa;    5286,&#xa;    5288,&#xa;    5290,&#xa;    5292,&#xa;    5294,&#xa;    5515,&#xa;    5734,&#xa;    5737,&#xa;    5746,&#xa;    5748,&#xa;    6193,&#xa;    6196,&#xa;    6198,&#xa;    6200,&#xa;    6202,&#xa;    6204,&#xa;    6206,&#xa;    6208,&#xa;    6250,&#xa;    6253,&#xa;    6255,&#xa;    6257,&#xa;    6259,&#xa;    6261,&#xa;    6263,&#xa;    6265,&#xa;    6893,&#xa;    6895,&#xa;    6897,&#xa;    6899,&#xa;    6902,&#xa;    6904,&#xa;    6906,&#xa;    6908,&#xa;    7035,&#xa;    7037,&#xa;    7039,&#xa;    7041,&#xa;    7044,&#xa;    7046,&#xa;    7048,&#xa;    7050,&#xa;    7713,&#xa;    7716,&#xa;    7718,&#xa;    7720,&#xa;    7722,&#xa;    7724,&#xa;    7726,&#xa;    7728,&#xa;    7869,&#xa;    8251,&#xa;    8254,&#xa;    8256,&#xa;    8258,&#xa;    8260,&#xa;    8262,&#xa;    8264,&#xa;    8266,&#xa;    8353,&#xa;    8356,&#xa;    8358,&#xa;    8360,&#xa;    8362,&#xa;    8364,&#xa;    8366,&#xa;    8368,&#xa;    9353,&#xa;    9356,&#xa;    9358,&#xa;    9360,&#xa;    9362,&#xa;    9364,&#xa;    9366,&#xa;    9368,&#xa;    9553,&#xa;    9555,&#xa;    9557,&#xa;    9559,&#xa;    9562,&#xa;    9564,&#xa;    9566,&#xa;    9568,&#xa;    9860,&#xa;    9864,&#xa;    9866,&#xa;    9869,&#xa;    9873,&#xa;    9875,&#xa;    11234,&#xa;    11238,&#xa;    11240,&#xa;    11243,&#xa;    11247,&#xa;    11249,&#xa;    11708,&#xa;    11716,&#xa;    17562,&#xa;    17564,&#xa;    17566,&#xa;    17568,&#xa;    17571,&#xa;    17573,&#xa;    17575,&#xa;    17577,&#xa;    17702,&#xa;    17704,&#xa;    17706,&#xa;    17708,&#xa;    17711,&#xa;    17713,&#xa;    17715,&#xa;    17717,&#xa;    20445,&#xa;    20447,&#xa;    20449,&#xa;    20451,&#xa;    20454,&#xa;    20456,&#xa;    20458,&#xa;    20460&#xa;}&#xa;&#xa;--[[&#xa;        Type definitions&#xa;--]]&#xa;&#xa;--- @class Position&#xa;--- @field x number Position x&#xa;--- @field y number Position y&#xa;--- @field z number Position z&#xa;&#xa;--- @class Item&#xa;--- @field id number ID of the item&#xa;--- @field count number Count of the item&#xa;&#xa;--- @class Tile&#xa;--- @field items Item[]&#xa;--- @field position Position&#xa;&#xa;--- @class Container&#xa;--- @field id number Index of the container&#xa;--- @field item Item Item representation of the container&#xa;--- @field items Item[] Array of items inside the container&#xa;--- @field name string Name of the container&#xa;&#xa;--[[&#xa;        User functions&#xa;--]]&#xa;&#xa;--- amount of current health percent&#xa;--- @author  Dworak&#xa;--- @return number&#xa;function hppc()&#xa;    local currentHP = hp()&#xa;    local maxHP = maxhp()&#xa;&#xa;    if currentHP > 0 and maxHP > 0 then&#xa;        local percentage = (currentHP / maxHP) * 100&#xa;        return percentage&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- amount of current mana percent&#xa;--- @author  Dworak&#xa;--- @return number&#xa;function mppc()&#xa;    local currentMP = mp()&#xa;    local maxMP = maxmp()&#xa;&#xa;    if currentMP > 0 and maxMP > 0 then&#xa;        local percentage = (currentMP / maxMP) * 100&#xa;        return percentage&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- check if player has any item by id&#xa;--- @author dulec&#xa;--- @param  itemid number Id of the item to check&#xa;--- @return boolean&#xa;function hasitem(itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;&#xa;    for _, container in ipairs(containers) do&#xa;        for _, item in ipairs(container.items) do&#xa;            if item.id == itemid then&#xa;                return true&#xa;            end&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- get all items on specific tile&#xa;--- @author  dulec&#xa;--- @param  position Position&#xa;--- @return Item[]|nil&#xa;function getitemsontile(position)&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        if tile.position.x == position.x and tile.position.y == position.y then&#xa;            return tile.items&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- move all items from position to destination&#xa;--- @author  dulec&#xa;--- @param   position Position Source position from where to move items&#xa;--- @param   destination Position Destination position to where to move items&#xa;--- @return  nil&#xa;function moveallitemsonground(position, destination)&#xa;    -- if getmetatable(position) ~= Position or getmetatable(destination) ~= Position then&#xa;    --    error(&quot;All arguments must be Positions&quot;)&#xa;    -- end&#xa;&#xa;    local itemsToMove = getitemsontile(position)&#xa;&#xa;    -- TODO: refactor and use itempropety(itemId, ITEM_IS_MOVABLE) to skip&#xa;    -- non-movable items&#xa;    table.remove(itemsToMove, 1)&#xa;&#xa;    for i = 1, #itemsToMove, 1 do&#xa;        local itemToRemove = itemsToMove[i]&#xa;        local count = itemToRemove.count&#xa;&#xa;        if itemToRemove.count == 0 then&#xa;            count = 1&#xa;        end&#xa;&#xa;        moveobject(position, itemToRemove.id, 1, destination, count)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- move all items from position to your position&#xa;--- @author  dulec&#xa;--- @param   position Position&#xa;--- @return  nil&#xa;function moveallitemstoyourposition(position)&#xa;    moveallitemsonground(position, selfposition())&#xa;end&#xa;&#xa;--- get stackpost of item from the tile&#xa;--- @author  szulak&#xa;--- @param   tile Tile&#xa;--- @param   itemid integer Item ID&#xa;--- @return  integer&#xa;function getitemstackpos(tile, itemid)&#xa;    for i = 1, #tile.items, 1 do&#xa;        if tile.items[i].id == itemid then&#xa;            return i - 1&#xa;        end&#xa;    end&#xa;&#xa;    return 0&#xa;end&#xa;&#xa;--- move items from position to destination&#xa;--- @author dulec&#xa;--- @param  position Position&#xa;--- @param  destination Position&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @return nil&#xa;function moveitemonground(position, destination, itemid, amount)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and amount must be numbers&quot;)&#xa;    end&#xa;&#xa;    -- if getmetatable(position) ~= Position or getmetatable(destination) ~= Position then&#xa;    --    error(&quot;position and destination arguments must be Positions&quot;)&#xa;    -- end&#xa;&#xa;    -- TODO: add check if there are enough items on position tile&#xa;&#xa;    local tile = gettile(position)&#xa;    local stackpos = getitemstackpos(tile, itemid)&#xa;&#xa;    while amount > 0 do&#xa;        if amount >= 100 then&#xa;            moveobject(position, itemid, stackpos, destination, 100)&#xa;            amount = amount - 100&#xa;        else&#xa;            moveobject(position, itemid, stackpos, destination, amount)&#xa;            amount = 0&#xa;        end&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- amount of items in cointainers by id&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   sourceLocation string&#xa;--- @return  number&#xa;function countitems(itemid, sourceLocation)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    if type(sourceLocation) == &quot;string&quot; then&#xa;        sourceLocation = sourceLocation:lower()&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    local count = 0&#xa;&#xa;    for _, container in ipairs(containers) do&#xa;        for _, item in ipairs(container.items) do&#xa;            if item.id == itemid and not sourceLocation or container.name:lower() == sourceLocation then&#xa;                if item.count == 0 then&#xa;                    count = count + 1&#xa;                else&#xa;                    count = count + item.count&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;    return count&#xa;end&#xa;&#xa;--- search all your containers until find first item with itemid and returns its position&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @return  Position|nil&#xa;function getitempositionfromcontainers(itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for _, container in ipairs(containers) do&#xa;        for j, item in ipairs(container.items) do&#xa;            if item.id == itemid then&#xa;                return Position:new(0xffff, 0x40 + container.id, j - 1)&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- drop specific items on floor, position optional(if nil will drop on self)&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   amount number&#xa;--- @param   position Position?&#xa;--- @return  nil&#xa;function dropitems(itemid, amount, position)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; and type(amount) ~= nil then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    if position == nil then&#xa;        position = selfposition()&#xa;    end&#xa;&#xa;    local itemscount = countitems(itemid)&#xa;    if itemscount &lt; amount then&#xa;        amount = itemscount&#xa;    end&#xa;&#xa;    while amount > 0 do&#xa;        local itemposition = getitempositionfromcontainers(itemid)&#xa;&#xa;        if (itemposition == nil) then&#xa;            return&#xa;        end&#xa;&#xa;        if amount >= 100 then&#xa;            moveobject(itemposition, itemid, itemposition.z, position, 100)&#xa;            amount = amount - 100&#xa;        else&#xa;            moveobject(itemposition, itemid, itemposition.z, position, amount)&#xa;            amount = 0&#xa;        end&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- returns self position&#xa;--- @author  dulec&#xa;--- @return  Position&#xa;function selfposition()&#xa;    return Position:new(posx(), posy(), posz())&#xa;end&#xa;&#xa;--- buy specific items up to amount&#xa;--- @author  dulec&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @param  ignorecap boolean?&#xa;--- @param  withbackpacks boolean?&#xa;--- @return nil&#xa;function buyitemsupto(itemid, amount, ignorecap, withbackpacks)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    ignorecap = ignorecap or false&#xa;    withbackpacks = withbackpacks or false&#xa;    buyobject(itemid, amount - countitems(itemid), ignorecap, withbackpacks)&#xa;    waitping()&#xa;end&#xa;&#xa;--- use itemid on objectid until it exists in position&#xa;--- @author  dulec&#xa;--- @param   position Position&#xa;--- @param   objectid number&#xa;--- @param   itemid number&#xa;--- @return  nil&#xa;function destroyobject(position, objectid, itemid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(objectid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and objectid must be numbers&quot;)&#xa;    end&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local toolposition = getitempositionfromcontainers(itemid)&#xa;    if toolposition == nil then&#xa;        error(&quot;You don't have specified tool&quot;)&#xa;    end&#xa;&#xa;    local tile = getitemsontile(position)&#xa;    local objectindex = finditemindex(tile, objectid)&#xa;&#xa;    while objectindex ~= -1 do&#xa;        usetwoobjects(toolposition, itemid, toolposition.z, position, objectid, objectindex)&#xa;        tile = getitemsontile(position)&#xa;        objectindex = finditemindex(tile, objectid)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- top item id on tile&#xa;--- @author  szulak&#xa;--- @param   extraFlags? number[] Array of additional flags to be checked&#xa;--- @return  Item&#xa;function topitem(position, extraFlags)&#xa;    extraFlags = extraFlags or {}&#xa;&#xa;    local tile = gettile(position)&#xa;    local ignoredFlags = { ITEM_BANK, ITEM_CLIP, ITEM_BOTTOM }&#xa;&#xa;    for i = 1, #tile.items, 1 do&#xa;        local itemid = tile.items[i].id&#xa;&#xa;        local skipitem = false&#xa;        for _, flag in ipairs(ignoredFlags) do&#xa;            if (itemproperty(itemid, flag)) then&#xa;                skipitem = true&#xa;                break&#xa;            end&#xa;        end&#xa;&#xa;        for _, flag in ipairs(extraFlags) do&#xa;            if not itemproperty(itemid, flag) then&#xa;                skipitem = true&#xa;                break&#xa;            end&#xa;        end&#xa;&#xa;        if skipitem == false then&#xa;            return tile.items[i]&#xa;        end&#xa;    end&#xa;&#xa;    return tile.items[#tile.items]&#xa;end&#xa;&#xa;--- top usable item id on tile&#xa;--- @author  mistgun&#xa;--- @param   position Position&#xa;--- @return  Item&#xa;function topuseitem(position)&#xa;    return topitem(position, { ITEM_USABLE })&#xa;end&#xa;&#xa;--- use itemid on object on ground&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   position Position&#xa;--- @return  nil&#xa;function useitemonground(itemid, position)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local itempos = getitempositionfromcontainers(itemid)&#xa;    if itempos == nil then&#xa;        error(&quot;You don't have specified item&quot;)&#xa;    end&#xa;&#xa;    items = getitemsontile(position)&#xa;&#xa;    usetwoobjects(itempos, itemid, itempos.z, position, items[1].id, 0)&#xa;end&#xa;&#xa;--- pickup amount of specified items from position to your backpack&#xa;--- @author dulec&#xa;--- @param  position Position&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @param  containerid number&#xa;--- @return nil&#xa;function pickupitems(position, itemid, amount, containerid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and amount must be numbers&quot;)&#xa;    end&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    containerid = containerid or 0&#xa;    amount = amount or 100&#xa;&#xa;    local itemindex = finditemindex(getitemsontile(position), itemid)&#xa;    if itemindex == -1 then&#xa;        return&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for i, container in ipairs(containers) do&#xa;        if container.id == containerid then&#xa;            for j, slot in ipairs(container.items) do&#xa;                if not itemproperty(slot.id, ITEM_CONTAINER) then&#xa;                    moveobject(position, itemid, itemindex, Position:new(0xffff, 0x40 + container.id, j - 1), amount)&#xa;                    waitping()&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- check if character know spell by id&#xa;--- @author  dulec&#xa;--- @param   spellid number&#xa;--- @return  boolean&#xa;function knowspell(spellid)&#xa;    if type(spellid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    spells = knownspells()&#xa;    for _, spell in ipairs(spells) do&#xa;        if spellid == spell.id then&#xa;            return true&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- cast spell levitate until floor index changes&#xa;--- @author  dulec&#xa;--- @param   spell string&#xa;--- @return  nil&#xa;function levitate(spell)&#xa;    if type(spell) ~= &quot;string&quot; then&#xa;        error(&quot;spell must be string&quot;)&#xa;    end&#xa;&#xa;    if mp() > 50 and level() >= 12 and knownspells(81) then&#xa;        local currentz = posz()&#xa;        while currentz == posz() do&#xa;            talk(MESSAGE_TYPE_SAY, spell)&#xa;            wait(1000)&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- reach itemid on ground&#xa;--- @param   itemid number&#xa;--- @param   avoid number&#xa;--- @author  dulec&#xa;--- @return  boolean&#xa;function reachgrounditem(itemid, avoid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(avoid) ~= &quot;number&quot; and type(avoid) ~= nil then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    avoid = avoid or 0&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        if finditemindex(tile.items, avoid) == -1 then&#xa;            for _, item in ipairs(tile.items) do&#xa;                if item.id == itemid then&#xa;                    reachlocation(tile.position.x, tile.position.y, tile.position.z)&#xa;                    return true&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- reaches nearest available depot&#xa;--- @author  dulec&#xa;--- @return  boolean&#xa;function reachdp()&#xa;    local creatureid = 99&#xa;&#xa;    -- TODO: this needs to be a lil bit more fancy - as the depot&#xa;    -- can be taken while the character is moving&#xa;&#xa;    return reachgrounditem(TILE_DEPOT_SWITCH, creatureid)&#xa;end&#xa;&#xa;--- keep trying to open hole and walk in until floor changes&#xa;--- @author  dulec&#xa;--- @param   direction string&#xa;--- @param   shovelid number&#xa;--- @return  boolean&#xa;function openholeandwalkin(direction, shovelid)&#xa;    if type(direction) ~= &quot;string&quot; then&#xa;        error(&quot;direction must be string&quot;)&#xa;    end&#xa;&#xa;    local diginposition = selfposition()&#xa;    direction = string.lower(direction)&#xa;    if string.find(direction, &quot;north&quot;) then&#xa;        diginposition.y = diginposition.y + 1&#xa;    end&#xa;    if string.find(direction, &quot;east&quot;) then&#xa;        diginposition.x = diginposition.x + 1&#xa;    end&#xa;    if string.find(direction, &quot;south&quot;) then&#xa;        diginposition.y = diginposition.y - 1&#xa;    end&#xa;    if string.find(direction, &quot;west&quot;) then&#xa;        diginposition.x = diginposition.x - 1&#xa;    end&#xa;&#xa;    -- TODO: this is tricky, since changing floor up/down offsets player&#xa;    -- .x and .y positon by +1 or -1 - thus, second reachlocation won't work&#xa;&#xa;    -- local originpos = selfposition()&#xa;    -- while originpos.z == selfposition().z do&#xa;    --    reachlocation(originpos.x, originpos.y, originpos.z)&#xa;    --    useitemonground(shovelid, diginposition)&#xa;    --    reachlocation(diginposition.x - 1, diginposition.y - 1, diginposition.z)&#xa;    --    waitping()&#xa;    -- end&#xa;end&#xa;&#xa;--- move your's character with choosen amount of steps&#xa;--- @author  Dworak&#xa;--- @param   direction string&#xa;--- @param   stepsAmount number&#xa;--- @return  nil&#xa;function move(direction, stepsAmount)&#xa;    local dir = nil&#xa;    direction = direction:lower()&#xa;    stepsAmount = stepsAmount or 1&#xa;&#xa;    if direction == &quot;n&quot; or direction == &quot;north&quot; then&#xa;        dir = STEP_DIRECTION_NORTH&#xa;    elseif direction == &quot;ne&quot; or direction == &quot;north-east&quot; or direction == &quot;northeast&quot; then&#xa;        dir = STEP_DIRECTION_NORTH_EAST&#xa;    elseif direction == &quot;e&quot; or direction == &quot;east&quot; then&#xa;        dir = STEP_DIRECTION_EAST&#xa;    elseif direction == &quot;se&quot; or direction == &quot;south-east&quot; or direction == &quot;southeast&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH_EAST&#xa;    elseif direction == &quot;s&quot; or direction == &quot;south&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH&#xa;    elseif direction == &quot;sw&quot; or direction == &quot;south-west&quot; or direction == &quot;southwest&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH_WEST&#xa;    elseif direction == &quot;w&quot; or direction == &quot;west&quot; then&#xa;        dir = STEP_DIRECTION_WEST&#xa;    elseif direction == &quot;nw&quot; or direction == &quot;north-west&quot; or direction == &quot;northwest&quot; then&#xa;        dir = STEP_DIRECTION_NORTH_WEST&#xa;    else&#xa;        return&#xa;    end&#xa;&#xa;    for i = 1, stepsAmount do&#xa;        step(dir)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- turn your's character with choosen direction&#xa;--- @author  Dworak&#xa;--- @param  direction string&#xa;--- @return nil&#xa;function turn(direction)&#xa;    direction = direction:lower()&#xa;    local dir = nil&#xa;&#xa;    if direction == &quot;n&quot; or direction == &quot;north&quot; then&#xa;        dir = DIRECTION_NORTH&#xa;    elseif direction == &quot;e&quot; or direction == &quot;east&quot; then&#xa;        dir = DIRECTION_EAST&#xa;    elseif direction == &quot;s&quot; or direction == &quot;south&quot; then&#xa;        dir = DIRECTION_SOUTH&#xa;    elseif direction == &quot;w&quot; or direction == &quot;west&quot; then&#xa;        dir = DIRECTION_WEST&#xa;    else&#xa;        return&#xa;    end&#xa;&#xa;    rotate(dir)&#xa;end&#xa;&#xa;--- returns true if your character is poisoned&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ispoisoned()&#xa;    return playerflag(PLAYER_FLAGS_POISON)&#xa;end&#xa;&#xa;--- returns true if your character is burning&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isburning()&#xa;    return playerflag(PLAYER_FLAGS_FIRE)&#xa;end&#xa;&#xa;--- returns true if your character is electrified&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function iselectrified()&#xa;    return playerflag(PLAYER_FLAGS_ENERGY)&#xa;end&#xa;&#xa;--- returns true if your character is drunk&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdrunk()&#xa;    return playerflag(PLAYER_FLAGS_DRUNK)&#xa;end&#xa;&#xa;--- returns true if your character is manashielded&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ismanashielded()&#xa;    return playerflag(PLAYER_FLAGS_MANA_SHIELD) or playerflag(PLAYER_FLAGS_MANA_SHIELD_NEW)&#xa;end&#xa;&#xa;--- returns true if your character is paralysed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isparalysed()&#xa;    return playerflag(PLAYER_FLAGS_PARALYSED)&#xa;end&#xa;&#xa;--- returns true if your character is hasted&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ishasted()&#xa;    return playerflag(PLAYER_FLAGS_HASTE)&#xa;end&#xa;&#xa;--- returns true if your character is battlesigned&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isbattlesigned()&#xa;    return playerflag(PLAYER_FLAGS_BATTLE)&#xa;end&#xa;&#xa;--- returns true if your character is drowning&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdrowning()&#xa;    return playerflag(PLAYER_FLAGS_DROWNING)&#xa;end&#xa;&#xa;--- returns true if your character is freezing&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isfreezing()&#xa;    return playerflag(PLAYER_FLAGS_FREEZING)&#xa;end&#xa;&#xa;--- returns true if your character is dazzled&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdazzled()&#xa;    return playerflag(PLAYER_FLAGS_DAZZLING)&#xa;end&#xa;&#xa;--- returns true if your character is cursed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function iscursed()&#xa;    return playerflag(PLAYER_FLAGS_CURSED)&#xa;end&#xa;&#xa;--- returns true if your character is strengthened&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isstrengthened()&#xa;    return playerflag(PLAYER_FLAGS_STRENGTHENED)&#xa;end&#xa;&#xa;--- returns true if your character is pvp singed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ispvpsigned()&#xa;    return playerflag(PLAYER_FLAGS_RED_SWORDS)&#xa;end&#xa;&#xa;--- returns true if your character is in protection zone&#xa;--- @author Dworak&#xa;--- @return boolean&#xa;function ispzone()&#xa;    return playerflag(PLAYER_FLAGS_PROTECTION_ZONE)&#xa;end&#xa;&#xa;--- returns true if your character is bleeding&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isbleeding()&#xa;    return playerflag(PLAYER_FLAGS_BLEEDING)&#xa;end&#xa;&#xa;--- returns hex level if your character is hexed&#xa;--- @author  Dworak&#xa;--- @return  number&#xa;function ishexed()&#xa;    if playerflag(PLAYER_FLAGS_GREATER_HEX) then&#xa;        return 3&#xa;    elseif playerflag(PLAYER_FLAGS_INTENSE_HEX) then&#xa;        return 2&#xa;    elseif playerflag(PLAYER_FLAGS_LESSER_HEX) then&#xa;        return 1&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- returns true if your character is rooted&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isrooted()&#xa;    return playerflag(PLAYER_FLAGS_ROOTED)&#xa;end&#xa;&#xa;--- returns true if your character is strengthened&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isfeared()&#xa;    return playerflag(PLAYER_FLAGS_FEARED)&#xa;end&#xa;&#xa;--- returns taint level if your character has taints&#xa;--- @author Dworak&#xa;--- @return number&#xa;function isgoshnar()&#xa;    if playerflag(PLAYER_FLAGS_GOSHNAR_5) then&#xa;        return 5&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_4) then&#xa;        return 4&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_3) then&#xa;        return 3&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_2) then&#xa;        return 2&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_1) then&#xa;        return 1&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;---  check if monster/player/NPC is on screen&#xa;--- @param   name string&#xa;--- @author  Loro&#xa;--- @return  boolean&#xa;function creatureonscreen(name)&#xa;    if type(name) ~= &quot;string&quot; then&#xa;        error(&quot;Monster name must be a string&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if c.name == name then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    return false&#xa;end&#xa;&#xa;--- return number of players in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function paround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local playersAround = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_PLAYER then&#xa;            playersAround = playersAround + 1&#xa;        end&#xa;    end&#xa;&#xa;    return playersAround&#xa;end&#xa;&#xa;--- return number of players in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function maround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local monstersAround = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_MONSTER then&#xa;            monstersAround = monstersAround + 1&#xa;        end&#xa;    end&#xa;&#xa;    return monstersAround&#xa;end&#xa;&#xa;--- return number of summons in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function saround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local around = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if&#xa;            math.floor(c.dist) &lt;= range and&#xa;            (c.type == CREATURE_TYPE_PLAYER_SUMMON or c.type == CREATURE_TYPE_OTHER_SUMMON)&#xa;        then&#xa;            around = around + 1&#xa;        end&#xa;    end&#xa;&#xa;    return around&#xa;end&#xa;&#xa;--- return number of NPC in range&#xa;--- @author Loro&#xa;--- @param  range number&#xa;--- @param  name string&#xa;--- @return number&#xa;function naround(range, name)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local around = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if name ~= nil and c.name == name then&#xa;            return 1&#xa;        end&#xa;&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_NPC then&#xa;            around = around + 1&#xa;        end&#xa;    end&#xa;&#xa;    return around&#xa;end&#xa;&#xa;--- follow/reach npc range by name&#xa;--- @author  Loro&#xa;--- @param   name string&#xa;--- @return  nil&#xa;function reachnpc(name)&#xa;    if type(name) ~= &quot;string&quot; then&#xa;        error(&quot;Npc name must be a string&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if c.type == CREATURE_TYPE_NPC and c.name == name then&#xa;            local npcpos = c.position&#xa;&#xa;            if tilereachable(npcpos.x, npcpos.y, npcpos.z) then&#xa;                follow(c.id)&#xa;                return&#xa;            end&#xa;&#xa;            for x = 1, 3 do&#xa;                for y = 1, 3 do&#xa;                    if tilereachable(npcpos.x + x, npcpos.y + y, npcpos.z) then&#xa;                        reachlocation(npcpos.x + x, npcpos.y + y, npcpos.z)&#xa;                        return&#xa;                    end&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- reach location specified by params, optionally keep specified distance from the destination&#xa;--- @author  szulak&#xa;--- @param  x number Position x&#xa;--- @param  y number Position y&#xa;--- @param  z number Position z&#xa;--- @param  dist? number Distance to keep from the desired location&#xa;--- @return boolean&#xa;function reachlocation(x, y, z, dist)&#xa;    if posz() ~= z then&#xa;        return false&#xa;    end&#xa;&#xa;    dist = dist or 0&#xa;&#xa;    local function findBestStandingSpot()&#xa;        if dist == 0 then&#xa;            return x, y&#xa;        end&#xa;&#xa;        local bestX, bestY&#xa;        local minDistToChar = math.huge&#xa;&#xa;        for dx = -7, 7 do&#xa;            for dy = -7, 7 do&#xa;                local checkX = x + dx&#xa;                local checkY = y + dy&#xa;&#xa;                if math.floor(distance(checkX, checkY, x, y)) == dist and tilereachable(checkX, checkY, z) then&#xa;                    local distToChar = distance(checkX, checkY, posx(), posy())&#xa;                    if distToChar &lt; minDistToChar then&#xa;                        minDistToChar = distToChar&#xa;                        bestX, bestY = checkX, checkY&#xa;                    end&#xa;                end&#xa;            end&#xa;        end&#xa;&#xa;        if bestX and bestY then&#xa;            return bestX, bestY&#xa;        end&#xa;    end&#xa;&#xa;    local bestSpotX, bestSpotY = findBestStandingSpot()&#xa;    local tries, maxTries = 0, 10&#xa;    local currX, currY = posx(), posy()&#xa;&#xa;    while currX ~= bestSpotX or currY ~= bestSpotY do&#xa;        if tries >= maxTries then&#xa;            return false&#xa;        end&#xa;&#xa;        steplocation(bestSpotX, bestSpotY, z)&#xa;        waitping()&#xa;&#xa;        if posx() == currX and posy() == currY then&#xa;            tries = tries + 1&#xa;        else&#xa;            tries = 0&#xa;            currX, currY = posx(), posy()&#xa;        end&#xa;&#xa;        bestSpotX, bestSpotY = findBestStandingSpot()&#xa;    end&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--- @name    find item index in items table, returns -1 when item has not been found in the table&#xa;--- @author  dulec&#xa;--- @param   itemlist Item[]&#xa;--- @param   itemid number&#xa;--- @return  number&#xa;function finditemindex(itemlist, itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    if #itemlist &lt; 1 then&#xa;        return -1&#xa;    end&#xa;&#xa;    for index, item in ipairs(itemlist) do&#xa;        if item.id == itemid then&#xa;            return index - 1&#xa;        end&#xa;    end&#xa;&#xa;    return -1&#xa;end&#xa;&#xa;--- @name    sstime&#xa;--- @author  spec8320&#xa;--- @desc    check if its server save time (from 9:55 AM till 10:10 AM)&#xa;--- @return  boolean&#xa;function sstime()&#xa;    return 600 >= secondtillss() or 85800 &lt;= secondtillss()&#xa;end&#xa;&#xa;--[[&#xa;        Helper functions&#xa;--]]&#xa;&#xa;--- returns time till server save in seconds. 0 means that it's ss time and 86400 means that there is 24h till next&#xa;--- @author spec8320&#xa;--- @return number&#xa;function secondtillss()&#xa;    return (36000 - cettime()) % 86400&#xa;end&#xa;&#xa;--- calculate distance between two points with euclidean formula as float&#xa;--- @author      spec8320&#xa;--- @param       x1 number&#xa;--- @param       y1 number&#xa;--- @param       x2 number&#xa;--- @param       y2 number&#xa;--- @return      number&#xa;function distance(x1, y1, x2, y2)&#xa;    -- Check if all arguments are numbers&#xa;    if type(x1) ~= &quot;number&quot; or type(y1) ~= &quot;number&quot; or type(x2) ~= &quot;number&quot; or type(y2) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    -- Calculate the distance using the Euclidean formula&#xa;    local distance = math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)&#xa;&#xa;    return distance&#xa;end&#xa;&#xa;--- get CET time&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function cettime()&#xa;    return utctime() - utcoffset() + cetoffset()&#xa;end&#xa;&#xa;--- get UTC time&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function utctime()&#xa;    local t = os.date(&quot;!%X&quot;)&#xa;&#xa;    -- Apparently os.date('!%X') returns the time with AM/PM appended on some&#xa;    -- computers; this ignores anything before and after the actual timestamp&#xa;    t = t:match(&quot;(%d%d:%d%d:%d%d)&quot;)&#xa;&#xa;    return tosec(t)&#xa;end&#xa;&#xa;--- get UTC timezone offset&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function utcoffset()&#xa;    local now = os.time()&#xa;    return os.difftime(os.time(os.date(&quot;!*t&quot;, now)), now)&#xa;end&#xa;&#xa;--- get CET timezone offset&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function cetoffset()&#xa;    -- See the difference an 'n' can do?&#xa;    local function iscest()&#xa;        -- List taken from http://www.timeanddate.com/time/zone/germany/frankfurt&#xa;        local daylightDates = {&#xa;            [2013] = { 90, 300 },&#xa;            [2014] = { 89, 299 },&#xa;            [2015] = { 88, 298 },&#xa;            [2016] = { 87, 304 },&#xa;            [2017] = { 85, 302 },&#xa;            [2018] = { 84, 301 },&#xa;            [2019] = { 90, 300 },&#xa;            [2023] = { 91, 301 },&#xa;            [2024] = { 87, 302 },&#xa;            [2025] = { 90, 300 }&#xa;        }&#xa;&#xa;        local now = os.date(&quot;!*t&quot;)&#xa;        local daylightDate = daylightDates[now.year]&#xa;&#xa;        return now.yday >= daylightDate[1] and now.yday &lt;= daylightDate[2]&#xa;    end&#xa;&#xa;    return utcoffset() + tern(iscest(), 7200, 3600)&#xa;end&#xa;&#xa;--- converting date format string to seconds&#xa;--- @author  spec8320&#xa;--- @param   str string&#xa;--- @return  number&#xa;function tosec(str)&#xa;    local sum, time, units, index = 0, str:token(nil, &quot;:&quot;), { 86400, 3600, 60, 1 }, 1&#xa;&#xa;    for i = #units - #time + 1, #units do&#xa;        sum, index = sum + ((tonumber(time[index]) or 0) * units[i]), index + 1&#xa;    end&#xa;&#xa;    return math.max(sum, 0)&#xa;end&#xa;&#xa;--- Helper for the ternary operator that Lua lacks. Returns `expr2` if `expr1` is true, `expr3` otherwise.&#xa;--- @author spec8320&#xa;--- @param expr1 any&#xa;--- @param expr2 any&#xa;--- @param expr3 any&#xa;--- @return any&#xa;function tern(expr1, expr2, expr3)&#xa;    if expr1 then&#xa;        return expr2&#xa;    else&#xa;        return expr3&#xa;    end&#xa;end&#xa;&#xa;--- Open or closes a door in position given. Returns true doors have been used to it's desired state.&#xa;--- @author mistgun&#xa;--- @param&#x9;position Position The door position&#xa;--- @param&#x9;action string close or open&#xa;--- |&quot;'close'&quot;&#xa;--- |&quot;'open'&quot;&#xa;--- @return  boolean&#xa;function usedoor(position, action)&#xa;    if not action or (action ~= &quot;open&quot; and action ~= &quot;close&quot;) then&#xa;        error('Valid action must be provided: &quot;open&quot; or &quot;close&quot;')&#xa;        return false&#xa;    end&#xa;&#xa;    reachlocation(position.x, position.y, position.z, 1)&#xa;&#xa;    local doorId, doorType = 0, &quot;&quot;&#xa;    local tile = gettile(position)&#xa;&#xa;    for _, item in ipairs(tile.items) do&#xa;        if table.contains(CLOSED_DOOR_IDS, item.id) then&#xa;            doorId = item.id&#xa;            doorType = &quot;close&quot;&#xa;            action = action or &quot;open&quot;&#xa;        elseif table.contains(OPENED_DOOR_IDS, item.id) then&#xa;            doorId = item.id&#xa;            doorType = &quot;open&quot;&#xa;            action = action or &quot;open&quot;&#xa;        end&#xa;&#xa;        if doorId ~= 0 then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    -- if a door wasn't found on the position it could mean the door id is not on the closeddoors table yet...&#xa;    if doorId == 0 then&#xa;        error((&quot;Unable to find a door at position x: %d, y: %d, z: %d.&quot;):format(position.x, position.y, position.z))&#xa;&#xa;        return false&#xa;    end&#xa;&#xa;    -- if doortype == action, means the door is already on the desired state...&#xa;    if doorType == action then&#xa;        return true&#xa;    end&#xa;&#xa;    local topUseId = topuseitem(position).id&#xa;    if action == &quot;open&quot; then&#xa;        while true do&#xa;            if topUseId == doorId then&#xa;                useobject(position, topUseId, 0, 0xFF)&#xa;                waitping()&#xa;            else&#xa;                return true&#xa;            end&#xa;&#xa;            topUseId = topuseitem(position).id&#xa;        end&#xa;    else&#xa;        while true do&#xa;            if topUseId == doorId then&#xa;                useobject(position, topUseId, 0, 0xFF)&#xa;                waitping()&#xa;&#xa;                -- # TODO: check if someone trashed the door spot, if so, move the trashed items&#xa;            else&#xa;                return true&#xa;            end&#xa;&#xa;            topUseId = topuseitem(position).id&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- returns true if the given item id is present on the tile specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; itemid number&#xa;--- @param&#x9; tile Tile tile object&#xa;--- @return  boolean&#xa;function isitemontile(itemid, tile)&#xa;    for _, item in ipairs(tile.items) do&#xa;        if item.id == itemid then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    return false&#xa;end&#xa;&#xa;--- returns true if the given item id is present on the position specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; itemid number&#xa;--- @param&#x9; position Position&#xa;--- @return  boolean&#xa;function isitemonposition(itemid, position)&#xa;    local tile = gettile(position.x, position.y, position.z)&#xa;    return isitemontile(itemid, tile)&#xa;end&#xa;&#xa;--- returns container by name or ID&#xa;--- @author  mistgun&#xa;--- @param&#x9; nameOrID string|number&#xa;--- @return  Container|nil&#xa;function getcontainer(nameOrID)&#xa;    if type(nameOrID) == &quot;string&quot; then&#xa;        nameOrID = nameOrID:lower()&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for _, container in ipairs(containers) do&#xa;        if container.name:lower() == nameOrID or container.item.id == nameOrID then&#xa;            return container&#xa;        end&#xa;    end&#xa;&#xa;    return nil&#xa;end&#xa;&#xa;--- returns direction from position given. If source position is not passed, it will return position from current character's position.&#xa;--- @author  mistgun&#xa;--- @param   direction string&#xa;--- @param   position? Position&#xa;--- @return  Position&#xa;function getdirposition(direction, position)&#xa;    x = position and position.x or posx()&#xa;    y = position and position.y or posy()&#xa;    z = position and position.z or posz()&#xa;&#xa;    local dir = {&#xa;        x = { c = 0, n = 0, s = 0, w = -1, e = 1, nw = -1, ne = 1, sw = -1, se = 1 },&#xa;        y = { c = 0, n = -1, s = 1, w = 0, e = 0, nw = -1, ne = -1, sw = 1, se = 1 }&#xa;    }&#xa;&#xa;    if not dir.x[direction] then&#xa;        error(&quot;Invalid direction specified&quot;)&#xa;    end&#xa;&#xa;    return Position:new(x + dir.x[direction], y + dir.y[direction], z)&#xa;end&#xa;&#xa;--- returns name of the depot box from it's corresponding index&#xa;--- @author  mistgun&#xa;--- @param&#x9; index number&#xa;--- @return  string&#xa;function getdepotboxnamefromindex(index)&#xa;    if index &lt; 1 or index > 20 then&#xa;        return &quot;&quot;&#xa;    end&#xa;&#xa;    local romanNumerals = {&#xa;        &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;,&#xa;        &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;, &quot;X&quot;,&#xa;        &quot;XI&quot;, &quot;XII&quot;, &quot;XIII&quot;, &quot;XIV&quot;, &quot;XV&quot;,&#xa;        &quot;XVI&quot;, &quot;XVII&quot;, &quot;XVIII&quot;, &quot;XIX&quot;, &quot;XX&quot;&#xa;    }&#xa;&#xa;    return &quot;depot box &quot; .. romanNumerals[index]&#xa;end&#xa;&#xa;--- returns ID of the depot box from it's corresponding index&#xa;--- @author  mistgun&#xa;--- @param&#x9; index number&#xa;--- @return  number&#xa;function getdepotboxidfromindex(index)&#xa;    if index &lt; 1 or index > 20 then&#xa;        return 0&#xa;    end&#xa;&#xa;    if index &lt; 18 then&#xa;        return 22796 + index&#xa;    end&#xa;&#xa;    -- last three boxes ids are not sequential&#xa;    local boxesIds = { [18] = 31915, [19] = 39723, [20] = 39724 }&#xa;    return boxesIds[index]&#xa;end&#xa;&#xa;--- opens specific object&#xa;--- @author  mistgun&#xa;--- @param   itemID number itemID to open&#xa;--- @param   locationFrom? string location name from where the given object should be opened, if none provided it will open the item from the first matching location&#xa;--- @param   asNew? boolean if true, the objectid will be opened as a new instance&#xa;--- @param   parentIndex? number index of parent object from which to open the given itemID (starts from 1)&#xa;--- @param   stackIndex? number  index of the itemID in the stack (starts from 1)&#xa;--- @return  boolean&#xa;function openobject(itemID, locationFrom, asNew, parentIndex, stackIndex)&#xa;    local fromContainer, parentPos = nil, 0&#xa;&#xa;    if type(locationFrom) == &quot;boolean&quot; then&#xa;        asNew = locationFrom&#xa;        locationFrom = nil&#xa;    elseif locationFrom == &quot;back&quot; then&#xa;        local objectPos = Position:new(0xffff, INVENTORY_BACKPACK, 0)&#xa;        useobject(objectPos, itemID, INVENTORY_BACKPACK, 0)&#xa;        return true&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for i, cont in ipairs(containers) do&#xa;        if locationFrom and cont.name == locationFrom then&#xa;            fromContainer = cont&#xa;            parentPos = i - 1&#xa;        elseif not locationFrom then&#xa;            for _, item in ipairs(cont.items) do&#xa;                if item.id == itemID then&#xa;                    fromContainer = cont&#xa;                    parentPos = i - 1&#xa;                    break&#xa;                end&#xa;            end&#xa;        end&#xa;&#xa;        if fromContainer and not parentIndex or parentPos + 1 == parentIndex then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    if not fromContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if asNew then&#xa;        parentPos = #containers&#xa;    end&#xa;&#xa;    local stackPos, index = -1, -1&#xa;    for i, item in ipairs(fromContainer.items) do&#xa;        if item.id == itemID then&#xa;            stackPos = i - 1&#xa;            index = index + 1&#xa;        end&#xa;&#xa;        if index + 1 == stackIndex then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    if stackPos == -1 then&#xa;        return false&#xa;    end&#xa;&#xa;    local objectPos = Position:new(0xffff, 0x40 + fromContainer.id, stackPos)&#xa;    useobject(objectPos, itemID, stackPos, parentPos)&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--- opens depot&#xa;--- @author  mistgun&#xa;--- @param   openType? string|number &quot;locker&quot;, &quot;depot&quot;, or depot number (1..20), when no param is passed defaults to &quot;depot&quot;&#xa;--- @return  boolean&#xa;function opendepot(openType)&#xa;    if type(openType) == &quot;string&quot; then&#xa;        openType = openType:lower()&#xa;&#xa;        if openType ~= &quot;locker&quot; and openType ~= &quot;depot&quot; then&#xa;            error(&quot;Valid options are 'locker' or 'depot'&quot;)&#xa;        end&#xa;    elseif type(openType) == &quot;number&quot; then&#xa;        if openType &lt; 1 or openType > 20 then&#xa;            error(&quot;Depot box number must be between 1 and 20&quot;)&#xa;        end&#xa;    else&#xa;        openType = &quot;depot&quot;&#xa;    end&#xa;&#xa;&#xa;    local depotBoxId = nil&#xa;    if openType == &quot;locker&quot; and getcontainer(&quot;locker&quot;) or openType == &quot;depot&quot; and getcontainer(&quot;depot chest&quot;) then&#xa;        return true&#xa;    elseif type(openType) == &quot;number&quot; then&#xa;        depotBoxName, depotBoxId = getdepotboxnamefromindex(openType), getdepotboxidfromindex(openType)&#xa;&#xa;        if getcontainer(depotBoxName) then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    local lockerPos, lockerSpot, lockerDist = nil, nil, math.huge&#xa;&#xa;    local lockers = { [3497] = 'n', [3499] = 's', [3450] = 'w', [3498] = 'e' }&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        local tilePos = tile.position&#xa;        local posX, posY, posZ = tilePos.x, tilePos.y, tilePos.z&#xa;        for id, dir in pairs(lockers) do&#xa;            local spot = getdirposition(dir, tilePos)&#xa;            -- TODO: simplify logic when tilereachable works properly for non-walkable tiles&#xa;            if isitemontile(id, tile) and tilereachable(spot.x, spot.y, spot.z) then&#xa;                local posDist = math.abs(posX - posx()) + math.abs(posY - posy())&#xa;&#xa;                if posDist &lt; lockerDist then&#xa;                    lockerPos = tile.position&#xa;                    lockerSpot = spot&#xa;                    lockerDist = posDist&#xa;                    break&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;&#xa;    if lockerSpot and tilereachable(lockerSpot.x, lockerSpot.y, lockerSpot.z) then&#xa;        reachlocation(lockerSpot.x, lockerSpot.y, lockerSpot.z)&#xa;    else&#xa;        return false&#xa;    end&#xa;&#xa;    local openLockerTries = 0&#xa;    while not getcontainer(&quot;locker&quot;) and openLockerTries &lt; 5 do&#xa;        if math.abs(lockerPos.x - posx()) > 1 or math.abs(lockerPos.y - posy()) > 1 then&#xa;            break&#xa;        end&#xa;&#xa;        local topUseId = topuseitem(lockerPos).id&#xa;&#xa;        useobject(lockerPos, topUseId, 0, 0xFF)&#xa;        wait(1300, 2000)&#xa;&#xa;        openLockerTries = openLockerTries + 1&#xa;    end&#xa;&#xa;    local lockerContainer = getcontainer(&quot;locker&quot;)&#xa;    if not lockerContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if openType == &quot;locker&quot; then&#xa;        return true&#xa;    end&#xa;&#xa;    local depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;    local openChestTries, depotChestId = 0, 3502&#xa;    while lockerContainer and not depotChestContainer and openChestTries &lt; 5 do&#xa;        openobject(depotChestId, &quot;locker&quot;,true)&#xa;        wait(1300, 2000)&#xa;&#xa;        lockerContainer = getcontainer(&quot;locker&quot;)&#xa;        depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;        openChestTries = openChestTries + 1&#xa;    end&#xa;&#xa;    if not depotChestContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if openType == &quot;depot&quot; then&#xa;        return true&#xa;    end&#xa;&#xa;    local depotBoxContainer = getcontainer(depotBoxName)&#xa;    local openBoxTries = 0&#xa;    while depotChestContainer and not depotBoxContainer and openBoxTries &lt; 5 do&#xa;        openobject(depotBoxId, &quot;depot chest&quot;,true)&#xa;        wait(1300, 2000)&#xa;&#xa;        depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;        depotBoxContainer = getcontainer(depotBoxName)&#xa;        openBoxTries = openBoxTries + 1&#xa;    end&#xa;&#xa;    return depotBoxContainer ~= nil and depotBoxContainer.name == depotBoxName&#xa;end&#xa;&#xa;--- closes all visible containers&#xa;--- @author  mistgun&#xa;function closecontainers()&#xa;    local containers = getcontainers()&#xa;&#xa;    while #containers > 0 do&#xa;        for _, cont in ipairs(containers) do&#xa;            closecontainer(cont.id)&#xa;            waitping()&#xa;        end&#xa;&#xa;        containers = getcontainers()&#xa;    end&#xa;end&#xa;&#xa;--- reopens backpacks specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; ... table The backpacks list as {id, locationName, asNew}.&#xa;--- @return  boolean&#xa;function reopenbps(...)&#xa;    local bps = { ... }&#xa;&#xa;    closecontainers()&#xa;    waitping()&#xa;&#xa;    for _, bp in ipairs(bps) do&#xa;        openobject(bp[1], bp[2], bp[3])&#xa;        wait(500, 800)&#xa;    end&#xa;end&#xa;&#xa;--- puts items from given backpack to desired depot boxes&#xa;--- @author  mistgun&#xa;--- @param   fromBpName string name of the bp inside a main backpack from which the items will be deposited&#xa;--- @param   stackBoxIndex number index of the depot box where stackable items will be deposited (defaults to 1)&#xa;--- @param   nonStackBoxIndex number index of the depot box where non-stackable items will be deposited (defaults to 1)&#xa;--- @return  boolean&#xa;function deposititems(fromBpName, stackBoxIndex, nonStackBoxIndex)&#xa;    stackBoxIndex = stackBoxIndex or 1&#xa;    nonStackBoxIndex = nonStackBoxIndex or stackBoxIndex&#xa;&#xa;    local lootBpContainer, depotContainer = getcontainer(fromBpName), getcontainer(&quot;depot chest&quot;)&#xa;    if not lootBpContainer or not depotContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    local function getFirstMatchingStorableItem()&#xa;        for index, item in ipairs(lootBpContainer.items) do&#xa;            local boxIndex = itemproperty(item.id, ITEM_CUMULATIVE) and stackBoxIndex or nonStackBoxIndex&#xa;            boxIndex = boxIndex - 1&#xa;&#xa;            local itemCount, itemStackPos = item.count == 0 and 1 or item.count, index - 1&#xa;&#xa;            if item.id ~= lootBpContainer.item.id and itemCount > 0 then&#xa;                local position = Position:new(0xffff, 0x40 + lootBpContainer.id, itemStackPos)&#xa;                local destPosition = Position:new(0xffff, 0x40 + depotContainer.id, boxIndex)&#xa;&#xa;                return position, item.id, itemStackPos, destPosition, itemCount&#xa;            end&#xa;        end&#xa;&#xa;        return nil&#xa;    end&#xa;&#xa;    while lootBpContainer and #lootBpContainer.items > 0 do&#xa;        lootBpContainer = getcontainer(fromBpName)&#xa;&#xa;        local position, itemID, itemStackPos, destPosition, itemCount = getFirstMatchingStorableItem()&#xa;&#xa;        local nextLootBpItemIndex = -1&#xa;        if not itemID then&#xa;            nextLootBpItemIndex = finditemindex(lootBpContainer.items, lootBpContainer.item.id)&#xa;&#xa;            if nextLootBpItemIndex == -1 then&#xa;                return true&#xa;            end&#xa;        end&#xa;&#xa;        if nextLootBpItemIndex ~= -1 then&#xa;            openobject(lootBpContainer.item.id, fromBpName, false, lootBpContainer.id + 1, nextLootBpItemIndex + 1)&#xa;            waitping()&#xa;        elseif itemID then&#xa;            moveobject(position, itemID, itemStackPos, destPosition, itemCount)&#xa;            waitping()&#xa;        end&#xa;    end&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--[[&#xa;Extensions&#xa;--]]&#xa;&#xa;--- checks if given element exists in the table&#xa;--- @author  spec8320&#xa;--- @param   table any[]&#xa;--- @param   element any&#xa;--- @return  boolean&#xa;function table.contains(table, element)&#xa;    for _, value in pairs(table) do&#xa;        if value == element then&#xa;            return true&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- removes nil values from the table&#xa;--- @author  mistgun&#xa;--- @return nil&#xa;function table.compact(self)&#xa;    for i = #self, 1, -1 do&#xa;        if self[i] == nil then&#xa;            table.remove(self, i)&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- randomizes the elements in the table&#xa;--- @author  mistgun&#xa;--- @return  nil&#xa;function table.shuffle(self)&#xa;    local index&#xa;    for i = #self, 1, -1 do&#xa;        index = math.random(i)&#xa;&#xa;        self[i], self[index] = self[index], self[i]&#xa;    end&#xa;end&#xa;&#xa;--- split token string with delimiter&#xa;--- @author spec8320&#xa;--- @return string&#xa;function string:token(n, delimiter)&#xa;    delimiter = delimiter or &quot; +&quot;&#xa;    local result = {}&#xa;    local from = 1&#xa;    local delim_from, delim_to = self:find(delimiter, from)&#xa;    while delim_from do&#xa;        table.insert(result, self:sub(from, delim_from - 1))&#xa;        from = delim_to + 1&#xa;        delim_from, delim_to = self:find(delimiter, from)&#xa;    end&#xa;    table.insert(result, self:sub(from))&#xa;    if n then&#xa;        return result[n]&#xa;    end&#xa;    return result&#xa;end&#xa;&#xa;local mainBpItem = getinventory(INVENTORY_BACKPACK)&#xa;local lootBpId = 2872 -- Camouflage Backpack&#xa;&#xa;reopenbps({mainBpItem.id, &quot;back&quot;}, { 2872, &quot;backpack&quot;, true}) &#xa;wait(1000)&#xa;opendepot(&quot;depot&quot;)&#xa;waitping(1000)&#xa;deposititems(&quot;Camouflage Backpack&quot;, 1, 2)&#xa;waitping()&#xa;closecontainers()&#xa;waitping()&#xa;reopenbps({mainBpItem.id, &quot;back&quot;}, { 2872, &quot;backpack&quot;, true}) " label="depositer" type="Action" x="32919" y="31478" z="7"/>
            <Waypoint action="" type="Node" x="32922" y="31493" z="7"/>
            <Waypoint action="" type="Stand" x="33947" y="31504" z="7"/>
			<Waypoint action="deposit gold" label="Bank" type="Action" x="33947" y="31504" z="7"/>
			<Waypoint action="" type="Stand" x="33910" y="31513" z="7"/>
            <Waypoint action="--- Buy Supply&#xa;--[[&#xa;    This file is part of the Tibia HoGBot (https://github.com/TibiaHoGBot/HoGBot-Library).&#xa;    Copyright (c) 2023 TIBIAHOGBOT LLC.&#xa;&#xa;    This program is free software: you can redistribute it and/or modify&#xa;    it under the terms of the GNU General Public License as published by&#xa;    the Free Software Foundation, version 3.&#xa;&#xa;    This program is distributed in the hope that it will be useful, but&#xa;    WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU&#xa;    General Public License for more details.&#xa;&#xa;    You should have received a copy of the GNU General Public License&#xa;    along with this program. If not, see &lt;http://www.gnu.org/licenses/>.&#xa;--]]&#xa;--[[&#xa;        Constants&#xa;--]]&#xa;CREATURE_TYPE_PLAYER = 0&#xa;CREATURE_TYPE_MONSTER = 1&#xa;CREATURE_TYPE_NPC = 2&#xa;CREATURE_TYPE_PLAYER_SUMMON = 3&#xa;CREATURE_TYPE_OTHER_SUMMON = 4&#xa;&#xa;DIRECTION_NORTH = 0&#xa;DIRECTION_EAST = 1&#xa;DIRECTION_SOUTH = 2&#xa;DIRECTION_WEST = 3&#xa;&#xa;INVENTORY_HELMET = 1&#xa;INVENTORY_NECKLACE = 2&#xa;INVENTORY_BACKPACK = 3&#xa;INVENTORY_ARMOR = 4&#xa;INVENTORY_SHIELD = 5&#xa;INVENTORY_WEAPON = 6&#xa;INVENTORY_LEGS = 7&#xa;INVENTORY_SHOES = 8&#xa;INVENTORY_RING = 9&#xa;INVENTORY_TRINKET = 10&#xa;&#xa;ITEM_BANK = 1&#xa;ITEM_CLIP = 2&#xa;ITEM_BOTTOM = 3&#xa;ITEM_TOP = 4&#xa;ITEM_CONTAINER = 5&#xa;ITEM_CUMULATIVE = 6&#xa;ITEM_USABLE = 7&#xa;ITEM_FORCEUSE = 8&#xa;ITEM_MULTIUSE = 9&#xa;ITEM_LIQUIDPOOL = 12&#xa;ITEM_UNPASS = 13&#xa;ITEM_UNMOVE = 14&#xa;ITEM_UNSIGHT = 15&#xa;ITEM_AVOID = 16&#xa;ITEM_NO_MOVE_ANIMATION = 17&#xa;ITEM_TAKE = 18&#xa;ITEM_LIQUID_CONTAINER = 19&#xa;ITEM_HANG = 20&#xa;ITEM_HOOK = 21&#xa;ITEM_ROTATE = 22&#xa;ITEM_LIGHT = 23&#xa;ITEM_DONT_HIDE = 24&#xa;ITEM_TRANSLUCENT = 25&#xa;ITEM_SHIFT = 26&#xa;ITEM_HEIGHT = 27&#xa;ITEM_LYING_OBJECT = 28&#xa;ITEM_ANIMATE_ALWAYS = 29&#xa;ITEM_AUTOMAP = 30&#xa;ITEM_LENS_HELP = 31&#xa;ITEM_FULLBANK = 32&#xa;ITEM_IGNORE_LOOK = 33&#xa;ITEM_CLOTHES = 34&#xa;ITEM_DEFAULT_ACTION = 35&#xa;ITEM_MARKET = 36&#xa;ITEM_WRAP = 37&#xa;ITEM_UNWRAP = 38&#xa;ITEM_TOP_EFFECT = 39&#xa;ITEM_NPC_SALE_DATA = 40&#xa;ITEM_CHANGED_TO_EXPIRE = 41&#xa;ITEM_CORPSE = 42&#xa;ITEM_PLAYER_CORPSE = 43&#xa;ITEM_CYCLOPEDIA_ITEM = 44&#xa;ITEM_AMMO = 45&#xa;ITEM_SHOW_OFF_SOCKET = 46&#xa;ITEM_REPORTABLE = 47&#xa;ITEM_UPGRADE_CLASSIFICATION = 48&#xa;ITEM_REVERSE_ADDONS_EAST = 49&#xa;ITEM_REVERSE_ADDONS_WEST = 50&#xa;ITEM_REVERSE_ADDONS_SOUTH = 51&#xa;ITEM_REVERSE_ADDONS_NORTH = 52&#xa;ITEM_WEAROUT = 53&#xa;ITEM_CLOCK_EXPIRE = 54&#xa;ITEM_EXPIRE = 55&#xa;ITEM_EXPIRE_STOP = 56&#xa;ITEM_DECO_ITEM_KIT = 57&#xa;&#xa;MESSAGE_TYPE_SAY = 1&#xa;MESSAGE_TYPE_WHISPER = 2&#xa;MESSAGE_TYPE_YELL = 3&#xa;MESSAGE_TYPE_NPC_TO = 12&#xa;MESSAGE_TYPE_LOOK = 22&#xa;MESSAGE_TYPE_STATUS = 30&#xa;MESSAGE_TYPE_LOOT = 31&#xa;&#xa;PLAYER_FLAGS_POISON = 1&#xa;PLAYER_FLAGS_FIRE = 2&#xa;PLAYER_FLAGS_ENERGY = 4&#xa;PLAYER_FLAGS_DRUNK = 8&#xa;PLAYER_FLAGS_MANA_SHIELD = 16&#xa;PLAYER_FLAGS_PARALYSED = 32&#xa;PLAYER_FLAGS_HASTE = 64&#xa;PLAYER_FLAGS_BATTLE = 128&#xa;PLAYER_FLAGS_DROWNING = 256&#xa;PLAYER_FLAGS_FREEZING = 512&#xa;PLAYER_FLAGS_DAZZLING = 1024&#xa;PLAYER_FLAGS_CURSED = 2048&#xa;PLAYER_FLAGS_STRENGTHENED = 4096&#xa;PLAYER_FLAGS_RED_SWORDS = 8192&#xa;PLAYER_FLAGS_PROTECTION_ZONE = 16384&#xa;PLAYER_FLAGS_BLEEDING = 32768&#xa;PLAYER_FLAGS_LESSER_HEX = 65536&#xa;PLAYER_FLAGS_INTENSE_HEX = 131072&#xa;PLAYER_FLAGS_GREATER_HEX = 262144&#xa;PLAYER_FLAGS_ROOTED = 524288&#xa;PLAYER_FLAGS_FEARED = 1048576&#xa;PLAYER_FLAGS_GOSHNAR_1 = 2097152&#xa;PLAYER_FLAGS_GOSHNAR_2 = 4194304&#xa;PLAYER_FLAGS_GOSHNAR_3 = 8388608&#xa;PLAYER_FLAGS_GOSHNAR_4 = 16777216&#xa;PLAYER_FLAGS_GOSHNAR_5 = 33554432&#xa;PLAYER_FLAGS_MANA_SHIELD_NEW = 67108864&#xa;&#xa;STEP_DIRECTION_EAST = 1&#xa;STEP_DIRECTION_NORTH_EAST = 2&#xa;STEP_DIRECTION_NORTH = 3&#xa;STEP_DIRECTION_NORTH_WEST = 4&#xa;STEP_DIRECTION_WEST = 5&#xa;STEP_DIRECTION_SOUTH_WEST = 6&#xa;STEP_DIRECTION_SOUTH = 7&#xa;STEP_DIRECTION_SOUTH_EAST = 8&#xa;&#xa;TILE_DEPOT_SWITCH = 31501&#xa;&#xa;local CLOSED_DOOR_IDS = {&#xa;    1628,&#xa;    1629,&#xa;    1631,&#xa;    1632,&#xa;    1638,&#xa;    1640,&#xa;    1642,&#xa;    1644,&#xa;    1646,&#xa;    1648,&#xa;    1650,&#xa;    1651,&#xa;    1653,&#xa;    1654,&#xa;    1656,&#xa;    1658,&#xa;    1660,&#xa;    1662,&#xa;    1664,&#xa;    1666,&#xa;    1668,&#xa;    1669,&#xa;    1671,&#xa;    1672,&#xa;    1674,&#xa;    1676,&#xa;    1678,&#xa;    1680,&#xa;    1682,&#xa;    1683,&#xa;    1685,&#xa;    1687,&#xa;    1689,&#xa;    1691,&#xa;    1692,&#xa;    1694,&#xa;    1696,&#xa;    1698,&#xa;    4912,&#xa;    4913,&#xa;    5006,&#xa;    5007,&#xa;    5082,&#xa;    5084,&#xa;    5097,&#xa;    5098,&#xa;    5100,&#xa;    5102,&#xa;    5104,&#xa;    5106,&#xa;    5107,&#xa;    5109,&#xa;    5111,&#xa;    5113,&#xa;    5115,&#xa;    5116,&#xa;    5118,&#xa;    5120,&#xa;    5122,&#xa;    5124,&#xa;    5125,&#xa;    5127,&#xa;    5129,&#xa;    5131,&#xa;    5133,&#xa;    5134,&#xa;    5136,&#xa;    5137,&#xa;    5139,&#xa;    5140,&#xa;    5142,&#xa;    5143,&#xa;    5277,&#xa;    5278,&#xa;    5280,&#xa;    5281,&#xa;    5282,&#xa;    5285,&#xa;    5287,&#xa;    5289,&#xa;    5291,&#xa;    5293,&#xa;    5302,&#xa;    5303,&#xa;    5514,&#xa;    5516,&#xa;    5732,&#xa;    5735,&#xa;    5745,&#xa;    5749,&#xa;    6191,&#xa;    6192,&#xa;    6194,&#xa;    6195,&#xa;    6197,&#xa;    6199,&#xa;    6201,&#xa;    6203,&#xa;    6205,&#xa;    6207,&#xa;    6248,&#xa;    6249,&#xa;    6251,&#xa;    6252,&#xa;    6254,&#xa;    6258,&#xa;    6260,&#xa;    6262,&#xa;    6264,&#xa;    6435,&#xa;    6436,&#xa;    6439,&#xa;    6440,&#xa;    6443,&#xa;    6444,&#xa;    6449,&#xa;    6450,&#xa;    6453,&#xa;    6454,&#xa;    6457,&#xa;    6458,&#xa;    6461,&#xa;    6462,&#xa;    6465,&#xa;    6466,&#xa;    6469,&#xa;    6470,&#xa;    6788,&#xa;    6789,&#xa;    6891,&#xa;    6892,&#xa;    6894,&#xa;    6896,&#xa;    6898,&#xa;    6900,&#xa;    6901,&#xa;    6903,&#xa;    6905,&#xa;    6907,&#xa;    7027,&#xa;    7028,&#xa;    7033,&#xa;    7034,&#xa;    7036,&#xa;    7038,&#xa;    7040,&#xa;    7042,&#xa;    7043,&#xa;    7045,&#xa;    7047,&#xa;    7049,&#xa;    7051,&#xa;    7052,&#xa;    7711,&#xa;    7712,&#xa;    7714,&#xa;    7715,&#xa;    7717,&#xa;    7719,&#xa;    7721,&#xa;    7723,&#xa;    7725,&#xa;    7727,&#xa;    7868,&#xa;    7941,&#xa;    8249,&#xa;    8250,&#xa;    8252,&#xa;    8253,&#xa;    8255,&#xa;    8257,&#xa;    8258,&#xa;    8261,&#xa;    8263,&#xa;    8265,&#xa;    8351,&#xa;    8352,&#xa;    8354,&#xa;    8355,&#xa;    8357,&#xa;    8359,&#xa;    8361,&#xa;    8363,&#xa;    8365,&#xa;    8367,&#xa;    9347,&#xa;    9348,&#xa;    9351,&#xa;    9352,&#xa;    9354,&#xa;    9355,&#xa;    9357,&#xa;    9359,&#xa;    9361,&#xa;    9363,&#xa;    9365,&#xa;    9367,&#xa;    9551,&#xa;    9552,&#xa;    9554,&#xa;    9556,&#xa;    9558,&#xa;    9560,&#xa;    9561,&#xa;    9563,&#xa;    9565,&#xa;    9567,&#xa;    9571,&#xa;    9572,&#xa;    9858,&#xa;    9859,&#xa;    9863,&#xa;    9865,&#xa;    9867,&#xa;    9868,&#xa;    9872,&#xa;    9874,&#xa;    10147,&#xa;    10149,&#xa;    10151,&#xa;    10153,&#xa;    10155,&#xa;    10157,&#xa;    10520,&#xa;    10521,&#xa;    11232,&#xa;    11233,&#xa;    11237,&#xa;    11239,&#xa;    11241,&#xa;    11242,&#xa;    11246,&#xa;    11248,&#xa;    11705,&#xa;    11714,&#xa;    17560,&#xa;    17561,&#xa;    17563,&#xa;    17565,&#xa;    17567,&#xa;    17569,&#xa;    17570,&#xa;    17572,&#xa;    17574,&#xa;    17576,&#xa;    17700,&#xa;    17701,&#xa;    17703,&#xa;    17705,&#xa;    17707,&#xa;    17709,&#xa;    17710,&#xa;    17712,&#xa;    17714,&#xa;    17716,&#xa;    20443,&#xa;    20444,&#xa;    20446,&#xa;    20448,&#xa;    20450,&#xa;    20452,&#xa;    20453,&#xa;    20455,&#xa;    20457,&#xa;    20459&#xa;}&#xa;local OPENED_DOOR_IDS = {&#xa;    1630,&#xa;    1633,&#xa;    1639,&#xa;    1641,&#xa;    1643,&#xa;    1645,&#xa;    1647,&#xa;    1649,&#xa;    1652,&#xa;    1655,&#xa;    1657,&#xa;    1659,&#xa;    1661,&#xa;    1663,&#xa;    1665,&#xa;    1667,&#xa;    1670,&#xa;    1673,&#xa;    1675,&#xa;    1677,&#xa;    1679,&#xa;    1681,&#xa;    1684,&#xa;    1686,&#xa;    1688,&#xa;    1690,&#xa;    1693,&#xa;    1695,&#xa;    1697,&#xa;    1699,&#xa;    2178,&#xa;    2180,&#xa;    4911,&#xa;    4914,&#xa;    5083,&#xa;    5085,&#xa;    5099,&#xa;    5101,&#xa;    5103,&#xa;    5105,&#xa;    5108,&#xa;    5110,&#xa;    5112,&#xa;    5114,&#xa;    5117,&#xa;    5117,&#xa;    5119,&#xa;    5121,&#xa;    5123,&#xa;    5126,&#xa;    5128,&#xa;    5130,&#xa;    5132,&#xa;    5135,&#xa;    5138,&#xa;    5141,&#xa;    5144,&#xa;    5279,&#xa;    5282,&#xa;    5284,&#xa;    5286,&#xa;    5288,&#xa;    5290,&#xa;    5292,&#xa;    5294,&#xa;    5515,&#xa;    5734,&#xa;    5737,&#xa;    5746,&#xa;    5748,&#xa;    6193,&#xa;    6196,&#xa;    6198,&#xa;    6200,&#xa;    6202,&#xa;    6204,&#xa;    6206,&#xa;    6208,&#xa;    6250,&#xa;    6253,&#xa;    6255,&#xa;    6257,&#xa;    6259,&#xa;    6261,&#xa;    6263,&#xa;    6265,&#xa;    6893,&#xa;    6895,&#xa;    6897,&#xa;    6899,&#xa;    6902,&#xa;    6904,&#xa;    6906,&#xa;    6908,&#xa;    7035,&#xa;    7037,&#xa;    7039,&#xa;    7041,&#xa;    7044,&#xa;    7046,&#xa;    7048,&#xa;    7050,&#xa;    7713,&#xa;    7716,&#xa;    7718,&#xa;    7720,&#xa;    7722,&#xa;    7724,&#xa;    7726,&#xa;    7728,&#xa;    7869,&#xa;    8251,&#xa;    8254,&#xa;    8256,&#xa;    8258,&#xa;    8260,&#xa;    8262,&#xa;    8264,&#xa;    8266,&#xa;    8353,&#xa;    8356,&#xa;    8358,&#xa;    8360,&#xa;    8362,&#xa;    8364,&#xa;    8366,&#xa;    8368,&#xa;    9353,&#xa;    9356,&#xa;    9358,&#xa;    9360,&#xa;    9362,&#xa;    9364,&#xa;    9366,&#xa;    9368,&#xa;    9553,&#xa;    9555,&#xa;    9557,&#xa;    9559,&#xa;    9562,&#xa;    9564,&#xa;    9566,&#xa;    9568,&#xa;    9860,&#xa;    9864,&#xa;    9866,&#xa;    9869,&#xa;    9873,&#xa;    9875,&#xa;    11234,&#xa;    11238,&#xa;    11240,&#xa;    11243,&#xa;    11247,&#xa;    11249,&#xa;    11708,&#xa;    11716,&#xa;    17562,&#xa;    17564,&#xa;    17566,&#xa;    17568,&#xa;    17571,&#xa;    17573,&#xa;    17575,&#xa;    17577,&#xa;    17702,&#xa;    17704,&#xa;    17706,&#xa;    17708,&#xa;    17711,&#xa;    17713,&#xa;    17715,&#xa;    17717,&#xa;    20445,&#xa;    20447,&#xa;    20449,&#xa;    20451,&#xa;    20454,&#xa;    20456,&#xa;    20458,&#xa;    20460&#xa;}&#xa;&#xa;--[[&#xa;        Type definitions&#xa;--]]&#xa;&#xa;--- @class Position&#xa;--- @field x number Position x&#xa;--- @field y number Position y&#xa;--- @field z number Position z&#xa;&#xa;--- @class Item&#xa;--- @field id number ID of the item&#xa;--- @field count number Count of the item&#xa;&#xa;--- @class Tile&#xa;--- @field items Item[]&#xa;--- @field position Position&#xa;&#xa;--- @class Container&#xa;--- @field id number Index of the container&#xa;--- @field item Item Item representation of the container&#xa;--- @field items Item[] Array of items inside the container&#xa;--- @field name string Name of the container&#xa;&#xa;--[[&#xa;        User functions&#xa;--]]&#xa;&#xa;--- amount of current health percent&#xa;--- @author  Dworak&#xa;--- @return number&#xa;function hppc()&#xa;    local currentHP = hp()&#xa;    local maxHP = maxhp()&#xa;&#xa;    if currentHP > 0 and maxHP > 0 then&#xa;        local percentage = (currentHP / maxHP) * 100&#xa;        return percentage&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- amount of current mana percent&#xa;--- @author  Dworak&#xa;--- @return number&#xa;function mppc()&#xa;    local currentMP = mp()&#xa;    local maxMP = maxmp()&#xa;&#xa;    if currentMP > 0 and maxMP > 0 then&#xa;        local percentage = (currentMP / maxMP) * 100&#xa;        return percentage&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- check if player has any item by id&#xa;--- @author dulec&#xa;--- @param  itemid number Id of the item to check&#xa;--- @return boolean&#xa;function hasitem(itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;&#xa;    for _, container in ipairs(containers) do&#xa;        for _, item in ipairs(container.items) do&#xa;            if item.id == itemid then&#xa;                return true&#xa;            end&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- get all items on specific tile&#xa;--- @author  dulec&#xa;--- @param  position Position&#xa;--- @return Item[]|nil&#xa;function getitemsontile(position)&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        if tile.position.x == position.x and tile.position.y == position.y then&#xa;            return tile.items&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- move all items from position to destination&#xa;--- @author  dulec&#xa;--- @param   position Position Source position from where to move items&#xa;--- @param   destination Position Destination position to where to move items&#xa;--- @return  nil&#xa;function moveallitemsonground(position, destination)&#xa;    -- if getmetatable(position) ~= Position or getmetatable(destination) ~= Position then&#xa;    --    error(&quot;All arguments must be Positions&quot;)&#xa;    -- end&#xa;&#xa;    local itemsToMove = getitemsontile(position)&#xa;&#xa;    -- TODO: refactor and use itempropety(itemId, ITEM_IS_MOVABLE) to skip&#xa;    -- non-movable items&#xa;    table.remove(itemsToMove, 1)&#xa;&#xa;    for i = 1, #itemsToMove, 1 do&#xa;        local itemToRemove = itemsToMove[i]&#xa;        local count = itemToRemove.count&#xa;&#xa;        if itemToRemove.count == 0 then&#xa;            count = 1&#xa;        end&#xa;&#xa;        moveobject(position, itemToRemove.id, 1, destination, count)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- move all items from position to your position&#xa;--- @author  dulec&#xa;--- @param   position Position&#xa;--- @return  nil&#xa;function moveallitemstoyourposition(position)&#xa;    moveallitemsonground(position, selfposition())&#xa;end&#xa;&#xa;--- get stackpost of item from the tile&#xa;--- @author  szulak&#xa;--- @param   tile Tile&#xa;--- @param   itemid integer Item ID&#xa;--- @return  integer&#xa;function getitemstackpos(tile, itemid)&#xa;    for i = 1, #tile.items, 1 do&#xa;        if tile.items[i].id == itemid then&#xa;            return i - 1&#xa;        end&#xa;    end&#xa;&#xa;    return 0&#xa;end&#xa;&#xa;--- move items from position to destination&#xa;--- @author dulec&#xa;--- @param  position Position&#xa;--- @param  destination Position&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @return nil&#xa;function moveitemonground(position, destination, itemid, amount)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and amount must be numbers&quot;)&#xa;    end&#xa;&#xa;    -- if getmetatable(position) ~= Position or getmetatable(destination) ~= Position then&#xa;    --    error(&quot;position and destination arguments must be Positions&quot;)&#xa;    -- end&#xa;&#xa;    -- TODO: add check if there are enough items on position tile&#xa;&#xa;    local tile = gettile(position)&#xa;    local stackpos = getitemstackpos(tile, itemid)&#xa;&#xa;    while amount > 0 do&#xa;        if amount >= 100 then&#xa;            moveobject(position, itemid, stackpos, destination, 100)&#xa;            amount = amount - 100&#xa;        else&#xa;            moveobject(position, itemid, stackpos, destination, amount)&#xa;            amount = 0&#xa;        end&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- amount of items in cointainers by id&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   sourceLocation string&#xa;--- @return  number&#xa;function countitems(itemid, sourceLocation)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    if type(sourceLocation) == &quot;string&quot; then&#xa;        sourceLocation = sourceLocation:lower()&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    local count = 0&#xa;&#xa;    for _, container in ipairs(containers) do&#xa;        for _, item in ipairs(container.items) do&#xa;            if item.id == itemid and not sourceLocation or container.name:lower() == sourceLocation then&#xa;                if item.count == 0 then&#xa;                    count = count + 1&#xa;                else&#xa;                    count = count + item.count&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;    return count&#xa;end&#xa;&#xa;--- search all your containers until find first item with itemid and returns its position&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @return  Position|nil&#xa;function getitempositionfromcontainers(itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for _, container in ipairs(containers) do&#xa;        for j, item in ipairs(container.items) do&#xa;            if item.id == itemid then&#xa;                return Position:new(0xffff, 0x40 + container.id, j - 1)&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- drop specific items on floor, position optional(if nil will drop on self)&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   amount number&#xa;--- @param   position Position?&#xa;--- @return  nil&#xa;function dropitems(itemid, amount, position)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; and type(amount) ~= nil then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    if position == nil then&#xa;        position = selfposition()&#xa;    end&#xa;&#xa;    local itemscount = countitems(itemid)&#xa;    if itemscount &lt; amount then&#xa;        amount = itemscount&#xa;    end&#xa;&#xa;    while amount > 0 do&#xa;        local itemposition = getitempositionfromcontainers(itemid)&#xa;&#xa;        if (itemposition == nil) then&#xa;            return&#xa;        end&#xa;&#xa;        if amount >= 100 then&#xa;            moveobject(itemposition, itemid, itemposition.z, position, 100)&#xa;            amount = amount - 100&#xa;        else&#xa;            moveobject(itemposition, itemid, itemposition.z, position, amount)&#xa;            amount = 0&#xa;        end&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- returns self position&#xa;--- @author  dulec&#xa;--- @return  Position&#xa;function selfposition()&#xa;    return Position:new(posx(), posy(), posz())&#xa;end&#xa;&#xa;--- buy specific items up to amount&#xa;--- @author  dulec&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @param  ignorecap boolean?&#xa;--- @param  withbackpacks boolean?&#xa;--- @return nil&#xa;function buyitemsupto(itemid, amount, ignorecap, withbackpacks)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    ignorecap = ignorecap or false&#xa;    withbackpacks = withbackpacks or false&#xa;    buyobject(itemid, amount - countitems(itemid), ignorecap, withbackpacks)&#xa;    waitping()&#xa;end&#xa;&#xa;--- use itemid on objectid until it exists in position&#xa;--- @author  dulec&#xa;--- @param   position Position&#xa;--- @param   objectid number&#xa;--- @param   itemid number&#xa;--- @return  nil&#xa;function destroyobject(position, objectid, itemid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(objectid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and objectid must be numbers&quot;)&#xa;    end&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local toolposition = getitempositionfromcontainers(itemid)&#xa;    if toolposition == nil then&#xa;        error(&quot;You don't have specified tool&quot;)&#xa;    end&#xa;&#xa;    local tile = getitemsontile(position)&#xa;    local objectindex = finditemindex(tile, objectid)&#xa;&#xa;    while objectindex ~= -1 do&#xa;        usetwoobjects(toolposition, itemid, toolposition.z, position, objectid, objectindex)&#xa;        tile = getitemsontile(position)&#xa;        objectindex = finditemindex(tile, objectid)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- top item id on tile&#xa;--- @author  szulak&#xa;--- @param   extraFlags? number[] Array of additional flags to be checked&#xa;--- @return  Item&#xa;function topitem(position, extraFlags)&#xa;    extraFlags = extraFlags or {}&#xa;&#xa;    local tile = gettile(position)&#xa;    local ignoredFlags = { ITEM_BANK, ITEM_CLIP, ITEM_BOTTOM }&#xa;&#xa;    for i = 1, #tile.items, 1 do&#xa;        local itemid = tile.items[i].id&#xa;&#xa;        local skipitem = false&#xa;        for _, flag in ipairs(ignoredFlags) do&#xa;            if (itemproperty(itemid, flag)) then&#xa;                skipitem = true&#xa;                break&#xa;            end&#xa;        end&#xa;&#xa;        for _, flag in ipairs(extraFlags) do&#xa;            if not itemproperty(itemid, flag) then&#xa;                skipitem = true&#xa;                break&#xa;            end&#xa;        end&#xa;&#xa;        if skipitem == false then&#xa;            return tile.items[i]&#xa;        end&#xa;    end&#xa;&#xa;    return tile.items[#tile.items]&#xa;end&#xa;&#xa;--- top usable item id on tile&#xa;--- @author  mistgun&#xa;--- @param   position Position&#xa;--- @return  Item&#xa;function topuseitem(position)&#xa;    return topitem(position, { ITEM_USABLE })&#xa;end&#xa;&#xa;--- use itemid on object on ground&#xa;--- @author  dulec&#xa;--- @param   itemid number&#xa;--- @param   position Position&#xa;--- @return  nil&#xa;function useitemonground(itemid, position)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    local itempos = getitempositionfromcontainers(itemid)&#xa;    if itempos == nil then&#xa;        error(&quot;You don't have specified item&quot;)&#xa;    end&#xa;&#xa;    items = getitemsontile(position)&#xa;&#xa;    usetwoobjects(itempos, itemid, itempos.z, position, items[1].id, 0)&#xa;end&#xa;&#xa;--- pickup amount of specified items from position to your backpack&#xa;--- @author dulec&#xa;--- @param  position Position&#xa;--- @param  itemid number&#xa;--- @param  amount number&#xa;--- @param  containerid number&#xa;--- @return nil&#xa;function pickupitems(position, itemid, amount, containerid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(amount) ~= &quot;number&quot; then&#xa;        error(&quot;itemid and amount must be numbers&quot;)&#xa;    end&#xa;    -- if getmetatable(position) ~= Position then&#xa;    --    error(&quot;position must be Position&quot;)&#xa;    -- end&#xa;&#xa;    containerid = containerid or 0&#xa;    amount = amount or 100&#xa;&#xa;    local itemindex = finditemindex(getitemsontile(position), itemid)&#xa;    if itemindex == -1 then&#xa;        return&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for i, container in ipairs(containers) do&#xa;        if container.id == containerid then&#xa;            for j, slot in ipairs(container.items) do&#xa;                if not itemproperty(slot.id, ITEM_CONTAINER) then&#xa;                    moveobject(position, itemid, itemindex, Position:new(0xffff, 0x40 + container.id, j - 1), amount)&#xa;                    waitping()&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- check if character know spell by id&#xa;--- @author  dulec&#xa;--- @param   spellid number&#xa;--- @return  boolean&#xa;function knowspell(spellid)&#xa;    if type(spellid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    spells = knownspells()&#xa;    for _, spell in ipairs(spells) do&#xa;        if spellid == spell.id then&#xa;            return true&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- cast spell levitate until floor index changes&#xa;--- @author  dulec&#xa;--- @param   spell string&#xa;--- @return  nil&#xa;function levitate(spell)&#xa;    if type(spell) ~= &quot;string&quot; then&#xa;        error(&quot;spell must be string&quot;)&#xa;    end&#xa;&#xa;    if mp() > 50 and level() >= 12 and knownspells(81) then&#xa;        local currentz = posz()&#xa;        while currentz == posz() do&#xa;            talk(MESSAGE_TYPE_SAY, spell)&#xa;            wait(1000)&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- reach itemid on ground&#xa;--- @param   itemid number&#xa;--- @param   avoid number&#xa;--- @author  dulec&#xa;--- @return  boolean&#xa;function reachgrounditem(itemid, avoid)&#xa;    if type(itemid) ~= &quot;number&quot; or type(avoid) ~= &quot;number&quot; and type(avoid) ~= nil then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    avoid = avoid or 0&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        if finditemindex(tile.items, avoid) == -1 then&#xa;            for _, item in ipairs(tile.items) do&#xa;                if item.id == itemid then&#xa;                    reachlocation(tile.position.x, tile.position.y, tile.position.z)&#xa;                    return true&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- reaches nearest available depot&#xa;--- @author  dulec&#xa;--- @return  boolean&#xa;function reachdp()&#xa;    local creatureid = 99&#xa;&#xa;    -- TODO: this needs to be a lil bit more fancy - as the depot&#xa;    -- can be taken while the character is moving&#xa;&#xa;    return reachgrounditem(TILE_DEPOT_SWITCH, creatureid)&#xa;end&#xa;&#xa;--- keep trying to open hole and walk in until floor changes&#xa;--- @author  dulec&#xa;--- @param   direction string&#xa;--- @param   shovelid number&#xa;--- @return  boolean&#xa;function openholeandwalkin(direction, shovelid)&#xa;    if type(direction) ~= &quot;string&quot; then&#xa;        error(&quot;direction must be string&quot;)&#xa;    end&#xa;&#xa;    local diginposition = selfposition()&#xa;    direction = string.lower(direction)&#xa;    if string.find(direction, &quot;north&quot;) then&#xa;        diginposition.y = diginposition.y + 1&#xa;    end&#xa;    if string.find(direction, &quot;east&quot;) then&#xa;        diginposition.x = diginposition.x + 1&#xa;    end&#xa;    if string.find(direction, &quot;south&quot;) then&#xa;        diginposition.y = diginposition.y - 1&#xa;    end&#xa;    if string.find(direction, &quot;west&quot;) then&#xa;        diginposition.x = diginposition.x - 1&#xa;    end&#xa;&#xa;    -- TODO: this is tricky, since changing floor up/down offsets player&#xa;    -- .x and .y positon by +1 or -1 - thus, second reachlocation won't work&#xa;&#xa;    -- local originpos = selfposition()&#xa;    -- while originpos.z == selfposition().z do&#xa;    --    reachlocation(originpos.x, originpos.y, originpos.z)&#xa;    --    useitemonground(shovelid, diginposition)&#xa;    --    reachlocation(diginposition.x - 1, diginposition.y - 1, diginposition.z)&#xa;    --    waitping()&#xa;    -- end&#xa;end&#xa;&#xa;--- move your's character with choosen amount of steps&#xa;--- @author  Dworak&#xa;--- @param   direction string&#xa;--- @param   stepsAmount number&#xa;--- @return  nil&#xa;function move(direction, stepsAmount)&#xa;    local dir = nil&#xa;    direction = direction:lower()&#xa;    stepsAmount = stepsAmount or 1&#xa;&#xa;    if direction == &quot;n&quot; or direction == &quot;north&quot; then&#xa;        dir = STEP_DIRECTION_NORTH&#xa;    elseif direction == &quot;ne&quot; or direction == &quot;north-east&quot; or direction == &quot;northeast&quot; then&#xa;        dir = STEP_DIRECTION_NORTH_EAST&#xa;    elseif direction == &quot;e&quot; or direction == &quot;east&quot; then&#xa;        dir = STEP_DIRECTION_EAST&#xa;    elseif direction == &quot;se&quot; or direction == &quot;south-east&quot; or direction == &quot;southeast&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH_EAST&#xa;    elseif direction == &quot;s&quot; or direction == &quot;south&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH&#xa;    elseif direction == &quot;sw&quot; or direction == &quot;south-west&quot; or direction == &quot;southwest&quot; then&#xa;        dir = STEP_DIRECTION_SOUTH_WEST&#xa;    elseif direction == &quot;w&quot; or direction == &quot;west&quot; then&#xa;        dir = STEP_DIRECTION_WEST&#xa;    elseif direction == &quot;nw&quot; or direction == &quot;north-west&quot; or direction == &quot;northwest&quot; then&#xa;        dir = STEP_DIRECTION_NORTH_WEST&#xa;    else&#xa;        return&#xa;    end&#xa;&#xa;    for i = 1, stepsAmount do&#xa;        step(dir)&#xa;        waitping()&#xa;    end&#xa;end&#xa;&#xa;--- turn your's character with choosen direction&#xa;--- @author  Dworak&#xa;--- @param  direction string&#xa;--- @return nil&#xa;function turn(direction)&#xa;    direction = direction:lower()&#xa;    local dir = nil&#xa;&#xa;    if direction == &quot;n&quot; or direction == &quot;north&quot; then&#xa;        dir = DIRECTION_NORTH&#xa;    elseif direction == &quot;e&quot; or direction == &quot;east&quot; then&#xa;        dir = DIRECTION_EAST&#xa;    elseif direction == &quot;s&quot; or direction == &quot;south&quot; then&#xa;        dir = DIRECTION_SOUTH&#xa;    elseif direction == &quot;w&quot; or direction == &quot;west&quot; then&#xa;        dir = DIRECTION_WEST&#xa;    else&#xa;        return&#xa;    end&#xa;&#xa;    rotate(dir)&#xa;end&#xa;&#xa;--- returns true if your character is poisoned&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ispoisoned()&#xa;    return playerflag(PLAYER_FLAGS_POISON)&#xa;end&#xa;&#xa;--- returns true if your character is burning&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isburning()&#xa;    return playerflag(PLAYER_FLAGS_FIRE)&#xa;end&#xa;&#xa;--- returns true if your character is electrified&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function iselectrified()&#xa;    return playerflag(PLAYER_FLAGS_ENERGY)&#xa;end&#xa;&#xa;--- returns true if your character is drunk&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdrunk()&#xa;    return playerflag(PLAYER_FLAGS_DRUNK)&#xa;end&#xa;&#xa;--- returns true if your character is manashielded&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ismanashielded()&#xa;    return playerflag(PLAYER_FLAGS_MANA_SHIELD) or playerflag(PLAYER_FLAGS_MANA_SHIELD_NEW)&#xa;end&#xa;&#xa;--- returns true if your character is paralysed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isparalysed()&#xa;    return playerflag(PLAYER_FLAGS_PARALYSED)&#xa;end&#xa;&#xa;--- returns true if your character is hasted&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ishasted()&#xa;    return playerflag(PLAYER_FLAGS_HASTE)&#xa;end&#xa;&#xa;--- returns true if your character is battlesigned&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isbattlesigned()&#xa;    return playerflag(PLAYER_FLAGS_BATTLE)&#xa;end&#xa;&#xa;--- returns true if your character is drowning&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdrowning()&#xa;    return playerflag(PLAYER_FLAGS_DROWNING)&#xa;end&#xa;&#xa;--- returns true if your character is freezing&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isfreezing()&#xa;    return playerflag(PLAYER_FLAGS_FREEZING)&#xa;end&#xa;&#xa;--- returns true if your character is dazzled&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isdazzled()&#xa;    return playerflag(PLAYER_FLAGS_DAZZLING)&#xa;end&#xa;&#xa;--- returns true if your character is cursed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function iscursed()&#xa;    return playerflag(PLAYER_FLAGS_CURSED)&#xa;end&#xa;&#xa;--- returns true if your character is strengthened&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isstrengthened()&#xa;    return playerflag(PLAYER_FLAGS_STRENGTHENED)&#xa;end&#xa;&#xa;--- returns true if your character is pvp singed&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function ispvpsigned()&#xa;    return playerflag(PLAYER_FLAGS_RED_SWORDS)&#xa;end&#xa;&#xa;--- returns true if your character is in protection zone&#xa;--- @author Dworak&#xa;--- @return boolean&#xa;function ispzone()&#xa;    return playerflag(PLAYER_FLAGS_PROTECTION_ZONE)&#xa;end&#xa;&#xa;--- returns true if your character is bleeding&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isbleeding()&#xa;    return playerflag(PLAYER_FLAGS_BLEEDING)&#xa;end&#xa;&#xa;--- returns hex level if your character is hexed&#xa;--- @author  Dworak&#xa;--- @return  number&#xa;function ishexed()&#xa;    if playerflag(PLAYER_FLAGS_GREATER_HEX) then&#xa;        return 3&#xa;    elseif playerflag(PLAYER_FLAGS_INTENSE_HEX) then&#xa;        return 2&#xa;    elseif playerflag(PLAYER_FLAGS_LESSER_HEX) then&#xa;        return 1&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;--- returns true if your character is rooted&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isrooted()&#xa;    return playerflag(PLAYER_FLAGS_ROOTED)&#xa;end&#xa;&#xa;--- returns true if your character is strengthened&#xa;--- @author  Dworak&#xa;--- @return  boolean&#xa;function isfeared()&#xa;    return playerflag(PLAYER_FLAGS_FEARED)&#xa;end&#xa;&#xa;--- returns taint level if your character has taints&#xa;--- @author Dworak&#xa;--- @return number&#xa;function isgoshnar()&#xa;    if playerflag(PLAYER_FLAGS_GOSHNAR_5) then&#xa;        return 5&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_4) then&#xa;        return 4&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_3) then&#xa;        return 3&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_2) then&#xa;        return 2&#xa;    elseif playerflag(PLAYER_FLAGS_GOSHNAR_1) then&#xa;        return 1&#xa;    else&#xa;        return 0&#xa;    end&#xa;end&#xa;&#xa;---  check if monster/player/NPC is on screen&#xa;--- @param   name string&#xa;--- @author  Loro&#xa;--- @return  boolean&#xa;function creatureonscreen(name)&#xa;    if type(name) ~= &quot;string&quot; then&#xa;        error(&quot;Monster name must be a string&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if c.name == name then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    return false&#xa;end&#xa;&#xa;--- return number of players in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function paround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local playersAround = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_PLAYER then&#xa;            playersAround = playersAround + 1&#xa;        end&#xa;    end&#xa;&#xa;    return playersAround&#xa;end&#xa;&#xa;--- return number of players in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function maround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local monstersAround = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_MONSTER then&#xa;            monstersAround = monstersAround + 1&#xa;        end&#xa;    end&#xa;&#xa;    return monstersAround&#xa;end&#xa;&#xa;--- return number of summons in range&#xa;--- @author  Loro&#xa;--- @param   range number&#xa;--- @return  number&#xa;function saround(range)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local around = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if&#xa;            math.floor(c.dist) &lt;= range and&#xa;            (c.type == CREATURE_TYPE_PLAYER_SUMMON or c.type == CREATURE_TYPE_OTHER_SUMMON)&#xa;        then&#xa;            around = around + 1&#xa;        end&#xa;    end&#xa;&#xa;    return around&#xa;end&#xa;&#xa;--- return number of NPC in range&#xa;--- @author Loro&#xa;--- @param  range number&#xa;--- @param  name string&#xa;--- @return number&#xa;function naround(range, name)&#xa;    if type(range) ~= &quot;number&quot; then&#xa;        error(&quot;Range must be a number&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;    local around = 0&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if name ~= nil and c.name == name then&#xa;            return 1&#xa;        end&#xa;&#xa;        if math.floor(c.dist) &lt;= range and c.type == CREATURE_TYPE_NPC then&#xa;            around = around + 1&#xa;        end&#xa;    end&#xa;&#xa;    return around&#xa;end&#xa;&#xa;--- follow/reach npc range by name&#xa;--- @author  Loro&#xa;--- @param   name string&#xa;--- @return  nil&#xa;function reachnpc(name)&#xa;    if type(name) ~= &quot;string&quot; then&#xa;        error(&quot;Npc name must be a string&quot;)&#xa;    end&#xa;&#xa;    local creatures = getcreatures()&#xa;&#xa;    for _, c in ipairs(creatures) do&#xa;        if c.type == CREATURE_TYPE_NPC and c.name == name then&#xa;            local npcpos = c.position&#xa;&#xa;            if tilereachable(npcpos.x, npcpos.y, npcpos.z) then&#xa;                follow(c.id)&#xa;                return&#xa;            end&#xa;&#xa;            for x = 1, 3 do&#xa;                for y = 1, 3 do&#xa;                    if tilereachable(npcpos.x + x, npcpos.y + y, npcpos.z) then&#xa;                        reachlocation(npcpos.x + x, npcpos.y + y, npcpos.z)&#xa;                        return&#xa;                    end&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- reach location specified by params, optionally keep specified distance from the destination&#xa;--- @author  szulak&#xa;--- @param  x number Position x&#xa;--- @param  y number Position y&#xa;--- @param  z number Position z&#xa;--- @param  dist? number Distance to keep from the desired location&#xa;--- @return boolean&#xa;function reachlocation(x, y, z, dist)&#xa;    if posz() ~= z then&#xa;        return false&#xa;    end&#xa;&#xa;    dist = dist or 0&#xa;&#xa;    local function findBestStandingSpot()&#xa;        if dist == 0 then&#xa;            return x, y&#xa;        end&#xa;&#xa;        local bestX, bestY&#xa;        local minDistToChar = math.huge&#xa;&#xa;        for dx = -7, 7 do&#xa;            for dy = -7, 7 do&#xa;                local checkX = x + dx&#xa;                local checkY = y + dy&#xa;&#xa;                if math.floor(distance(checkX, checkY, x, y)) == dist and tilereachable(checkX, checkY, z) then&#xa;                    local distToChar = distance(checkX, checkY, posx(), posy())&#xa;                    if distToChar &lt; minDistToChar then&#xa;                        minDistToChar = distToChar&#xa;                        bestX, bestY = checkX, checkY&#xa;                    end&#xa;                end&#xa;            end&#xa;        end&#xa;&#xa;        if bestX and bestY then&#xa;            return bestX, bestY&#xa;        end&#xa;    end&#xa;&#xa;    local bestSpotX, bestSpotY = findBestStandingSpot()&#xa;    local tries, maxTries = 0, 10&#xa;    local currX, currY = posx(), posy()&#xa;&#xa;    while currX ~= bestSpotX or currY ~= bestSpotY do&#xa;        if tries >= maxTries then&#xa;            return false&#xa;        end&#xa;&#xa;        steplocation(bestSpotX, bestSpotY, z)&#xa;        waitping()&#xa;&#xa;        if posx() == currX and posy() == currY then&#xa;            tries = tries + 1&#xa;        else&#xa;            tries = 0&#xa;            currX, currY = posx(), posy()&#xa;        end&#xa;&#xa;        bestSpotX, bestSpotY = findBestStandingSpot()&#xa;    end&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--- @name    find item index in items table, returns -1 when item has not been found in the table&#xa;--- @author  dulec&#xa;--- @param   itemlist Item[]&#xa;--- @param   itemid number&#xa;--- @return  number&#xa;function finditemindex(itemlist, itemid)&#xa;    if type(itemid) ~= &quot;number&quot; then&#xa;        error(&quot;itemid must be number&quot;)&#xa;    end&#xa;&#xa;    if #itemlist &lt; 1 then&#xa;        return -1&#xa;    end&#xa;&#xa;    for index, item in ipairs(itemlist) do&#xa;        if item.id == itemid then&#xa;            return index - 1&#xa;        end&#xa;    end&#xa;&#xa;    return -1&#xa;end&#xa;&#xa;--- @name    sstime&#xa;--- @author  spec8320&#xa;--- @desc    check if its server save time (from 9:55 AM till 10:10 AM)&#xa;--- @return  boolean&#xa;function sstime()&#xa;    return 600 >= secondtillss() or 85800 &lt;= secondtillss()&#xa;end&#xa;&#xa;--[[&#xa;        Helper functions&#xa;--]]&#xa;&#xa;--- returns time till server save in seconds. 0 means that it's ss time and 86400 means that there is 24h till next&#xa;--- @author spec8320&#xa;--- @return number&#xa;function secondtillss()&#xa;    return (36000 - cettime()) % 86400&#xa;end&#xa;&#xa;--- calculate distance between two points with euclidean formula as float&#xa;--- @author      spec8320&#xa;--- @param       x1 number&#xa;--- @param       y1 number&#xa;--- @param       x2 number&#xa;--- @param       y2 number&#xa;--- @return      number&#xa;function distance(x1, y1, x2, y2)&#xa;    -- Check if all arguments are numbers&#xa;    if type(x1) ~= &quot;number&quot; or type(y1) ~= &quot;number&quot; or type(x2) ~= &quot;number&quot; or type(y2) ~= &quot;number&quot; then&#xa;        error(&quot;All arguments must be numbers&quot;)&#xa;    end&#xa;&#xa;    -- Calculate the distance using the Euclidean formula&#xa;    local distance = math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)&#xa;&#xa;    return distance&#xa;end&#xa;&#xa;--- get CET time&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function cettime()&#xa;    return utctime() - utcoffset() + cetoffset()&#xa;end&#xa;&#xa;--- get UTC time&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function utctime()&#xa;    local t = os.date(&quot;!%X&quot;)&#xa;&#xa;    -- Apparently os.date('!%X') returns the time with AM/PM appended on some&#xa;    -- computers; this ignores anything before and after the actual timestamp&#xa;    t = t:match(&quot;(%d%d:%d%d:%d%d)&quot;)&#xa;&#xa;    return tosec(t)&#xa;end&#xa;&#xa;--- get UTC timezone offset&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function utcoffset()&#xa;    local now = os.time()&#xa;    return os.difftime(os.time(os.date(&quot;!*t&quot;, now)), now)&#xa;end&#xa;&#xa;--- get CET timezone offset&#xa;--- @author  spec8320&#xa;--- @return  number&#xa;function cetoffset()&#xa;    -- See the difference an 'n' can do?&#xa;    local function iscest()&#xa;        -- List taken from http://www.timeanddate.com/time/zone/germany/frankfurt&#xa;        local daylightDates = {&#xa;            [2013] = { 90, 300 },&#xa;            [2014] = { 89, 299 },&#xa;            [2015] = { 88, 298 },&#xa;            [2016] = { 87, 304 },&#xa;            [2017] = { 85, 302 },&#xa;            [2018] = { 84, 301 },&#xa;            [2019] = { 90, 300 },&#xa;            [2023] = { 91, 301 },&#xa;            [2024] = { 87, 302 },&#xa;            [2025] = { 90, 300 }&#xa;        }&#xa;&#xa;        local now = os.date(&quot;!*t&quot;)&#xa;        local daylightDate = daylightDates[now.year]&#xa;&#xa;        return now.yday >= daylightDate[1] and now.yday &lt;= daylightDate[2]&#xa;    end&#xa;&#xa;    return utcoffset() + tern(iscest(), 7200, 3600)&#xa;end&#xa;&#xa;--- converting date format string to seconds&#xa;--- @author  spec8320&#xa;--- @param   str string&#xa;--- @return  number&#xa;function tosec(str)&#xa;    local sum, time, units, index = 0, str:token(nil, &quot;:&quot;), { 86400, 3600, 60, 1 }, 1&#xa;&#xa;    for i = #units - #time + 1, #units do&#xa;        sum, index = sum + ((tonumber(time[index]) or 0) * units[i]), index + 1&#xa;    end&#xa;&#xa;    return math.max(sum, 0)&#xa;end&#xa;&#xa;--- Helper for the ternary operator that Lua lacks. Returns `expr2` if `expr1` is true, `expr3` otherwise.&#xa;--- @author spec8320&#xa;--- @param expr1 any&#xa;--- @param expr2 any&#xa;--- @param expr3 any&#xa;--- @return any&#xa;function tern(expr1, expr2, expr3)&#xa;    if expr1 then&#xa;        return expr2&#xa;    else&#xa;        return expr3&#xa;    end&#xa;end&#xa;&#xa;--- Open or closes a door in position given. Returns true doors have been used to it's desired state.&#xa;--- @author mistgun&#xa;--- @param&#x9;position Position The door position&#xa;--- @param&#x9;action string close or open&#xa;--- |&quot;'close'&quot;&#xa;--- |&quot;'open'&quot;&#xa;--- @return  boolean&#xa;function usedoor(position, action)&#xa;    if not action or (action ~= &quot;open&quot; and action ~= &quot;close&quot;) then&#xa;        error('Valid action must be provided: &quot;open&quot; or &quot;close&quot;')&#xa;        return false&#xa;    end&#xa;&#xa;    reachlocation(position.x, position.y, position.z, 1)&#xa;&#xa;    local doorId, doorType = 0, &quot;&quot;&#xa;    local tile = gettile(position)&#xa;&#xa;    for _, item in ipairs(tile.items) do&#xa;        if table.contains(CLOSED_DOOR_IDS, item.id) then&#xa;            doorId = item.id&#xa;            doorType = &quot;close&quot;&#xa;            action = action or &quot;open&quot;&#xa;        elseif table.contains(OPENED_DOOR_IDS, item.id) then&#xa;            doorId = item.id&#xa;            doorType = &quot;open&quot;&#xa;            action = action or &quot;open&quot;&#xa;        end&#xa;&#xa;        if doorId ~= 0 then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    -- if a door wasn't found on the position it could mean the door id is not on the closeddoors table yet...&#xa;    if doorId == 0 then&#xa;        error((&quot;Unable to find a door at position x: %d, y: %d, z: %d.&quot;):format(position.x, position.y, position.z))&#xa;&#xa;        return false&#xa;    end&#xa;&#xa;    -- if doortype == action, means the door is already on the desired state...&#xa;    if doorType == action then&#xa;        return true&#xa;    end&#xa;&#xa;    local topUseId = topuseitem(position).id&#xa;    if action == &quot;open&quot; then&#xa;        while true do&#xa;            if topUseId == doorId then&#xa;                useobject(position, topUseId, 0, 0xFF)&#xa;                waitping()&#xa;            else&#xa;                return true&#xa;            end&#xa;&#xa;            topUseId = topuseitem(position).id&#xa;        end&#xa;    else&#xa;        while true do&#xa;            if topUseId == doorId then&#xa;                useobject(position, topUseId, 0, 0xFF)&#xa;                waitping()&#xa;&#xa;                -- # TODO: check if someone trashed the door spot, if so, move the trashed items&#xa;            else&#xa;                return true&#xa;            end&#xa;&#xa;            topUseId = topuseitem(position).id&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- returns true if the given item id is present on the tile specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; itemid number&#xa;--- @param&#x9; tile Tile tile object&#xa;--- @return  boolean&#xa;function isitemontile(itemid, tile)&#xa;    for _, item in ipairs(tile.items) do&#xa;        if item.id == itemid then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    return false&#xa;end&#xa;&#xa;--- returns true if the given item id is present on the position specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; itemid number&#xa;--- @param&#x9; position Position&#xa;--- @return  boolean&#xa;function isitemonposition(itemid, position)&#xa;    local tile = gettile(position.x, position.y, position.z)&#xa;    return isitemontile(itemid, tile)&#xa;end&#xa;&#xa;--- returns container by name or ID&#xa;--- @author  mistgun&#xa;--- @param&#x9; nameOrID string|number&#xa;--- @return  Container|nil&#xa;function getcontainer(nameOrID)&#xa;    if type(nameOrID) == &quot;string&quot; then&#xa;        nameOrID = nameOrID:lower()&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for _, container in ipairs(containers) do&#xa;        if container.name:lower() == nameOrID or container.item.id == nameOrID then&#xa;            return container&#xa;        end&#xa;    end&#xa;&#xa;    return nil&#xa;end&#xa;&#xa;--- returns direction from position given. If source position is not passed, it will return position from current character's position.&#xa;--- @author  mistgun&#xa;--- @param   direction string&#xa;--- @param   position? Position&#xa;--- @return  Position&#xa;function getdirposition(direction, position)&#xa;    x = position and position.x or posx()&#xa;    y = position and position.y or posy()&#xa;    z = position and position.z or posz()&#xa;&#xa;    local dir = {&#xa;        x = { c = 0, n = 0, s = 0, w = -1, e = 1, nw = -1, ne = 1, sw = -1, se = 1 },&#xa;        y = { c = 0, n = -1, s = 1, w = 0, e = 0, nw = -1, ne = -1, sw = 1, se = 1 }&#xa;    }&#xa;&#xa;    if not dir.x[direction] then&#xa;        error(&quot;Invalid direction specified&quot;)&#xa;    end&#xa;&#xa;    return Position:new(x + dir.x[direction], y + dir.y[direction], z)&#xa;end&#xa;&#xa;--- returns name of the depot box from it's corresponding index&#xa;--- @author  mistgun&#xa;--- @param&#x9; index number&#xa;--- @return  string&#xa;function getdepotboxnamefromindex(index)&#xa;    if index &lt; 1 or index > 20 then&#xa;        return &quot;&quot;&#xa;    end&#xa;&#xa;    local romanNumerals = {&#xa;        &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;,&#xa;        &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;, &quot;X&quot;,&#xa;        &quot;XI&quot;, &quot;XII&quot;, &quot;XIII&quot;, &quot;XIV&quot;, &quot;XV&quot;,&#xa;        &quot;XVI&quot;, &quot;XVII&quot;, &quot;XVIII&quot;, &quot;XIX&quot;, &quot;XX&quot;&#xa;    }&#xa;&#xa;    return &quot;depot box &quot; .. romanNumerals[index]&#xa;end&#xa;&#xa;--- returns ID of the depot box from it's corresponding index&#xa;--- @author  mistgun&#xa;--- @param&#x9; index number&#xa;--- @return  number&#xa;function getdepotboxidfromindex(index)&#xa;    if index &lt; 1 or index > 20 then&#xa;        return 0&#xa;    end&#xa;&#xa;    if index &lt; 18 then&#xa;        return 22796 + index&#xa;    end&#xa;&#xa;    -- last three boxes ids are not sequential&#xa;    local boxesIds = { [18] = 31915, [19] = 39723, [20] = 39724 }&#xa;    return boxesIds[index]&#xa;end&#xa;&#xa;--- opens specific object&#xa;--- @author  mistgun&#xa;--- @param   itemID number itemID to open&#xa;--- @param   locationFrom? string location name from where the given object should be opened, if none provided it will open the item from the first matching location&#xa;--- @param   asNew? boolean if true, the objectid will be opened as a new instance&#xa;--- @param   parentIndex? number index of parent object from which to open the given itemID (starts from 1)&#xa;--- @param   stackIndex? number  index of the itemID in the stack (starts from 1)&#xa;--- @return  boolean&#xa;function openobject(itemID, locationFrom, asNew, parentIndex, stackIndex)&#xa;    local fromContainer, parentPos = nil, 0&#xa;&#xa;    if type(locationFrom) == &quot;boolean&quot; then&#xa;        asNew = locationFrom&#xa;        locationFrom = nil&#xa;    elseif locationFrom == &quot;back&quot; then&#xa;        local objectPos = Position:new(0xffff, INVENTORY_BACKPACK, 0)&#xa;        useobject(objectPos, itemID, INVENTORY_BACKPACK, 0)&#xa;        return true&#xa;    end&#xa;&#xa;    local containers = getcontainers()&#xa;    for i, cont in ipairs(containers) do&#xa;        if locationFrom and cont.name == locationFrom then&#xa;            fromContainer = cont&#xa;            parentPos = i - 1&#xa;        elseif not locationFrom then&#xa;            for _, item in ipairs(cont.items) do&#xa;                if item.id == itemID then&#xa;                    fromContainer = cont&#xa;                    parentPos = i - 1&#xa;                    break&#xa;                end&#xa;            end&#xa;        end&#xa;&#xa;        if fromContainer and not parentIndex or parentPos + 1 == parentIndex then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    if not fromContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if asNew then&#xa;        parentPos = #containers&#xa;    end&#xa;&#xa;    local stackPos, index = -1, -1&#xa;    for i, item in ipairs(fromContainer.items) do&#xa;        if item.id == itemID then&#xa;            stackPos = i - 1&#xa;            index = index + 1&#xa;        end&#xa;&#xa;        if index + 1 == stackIndex then&#xa;            break&#xa;        end&#xa;    end&#xa;&#xa;    if stackPos == -1 then&#xa;        return false&#xa;    end&#xa;&#xa;    local objectPos = Position:new(0xffff, 0x40 + fromContainer.id, stackPos)&#xa;    useobject(objectPos, itemID, stackPos, parentPos)&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--- opens depot&#xa;--- @author  mistgun&#xa;--- @param   openType? string|number &quot;locker&quot;, &quot;depot&quot;, or depot number (1..20), when no param is passed defaults to &quot;depot&quot;&#xa;--- @return  boolean&#xa;function opendepot(openType)&#xa;    if type(openType) == &quot;string&quot; then&#xa;        openType = openType:lower()&#xa;&#xa;        if openType ~= &quot;locker&quot; and openType ~= &quot;depot&quot; then&#xa;            error(&quot;Valid options are 'locker' or 'depot'&quot;)&#xa;        end&#xa;    elseif type(openType) == &quot;number&quot; then&#xa;        if openType &lt; 1 or openType > 20 then&#xa;            error(&quot;Depot box number must be between 1 and 20&quot;)&#xa;        end&#xa;    else&#xa;        openType = &quot;depot&quot;&#xa;    end&#xa;&#xa;&#xa;    local depotBoxId = nil&#xa;    if openType == &quot;locker&quot; and getcontainer(&quot;locker&quot;) or openType == &quot;depot&quot; and getcontainer(&quot;depot chest&quot;) then&#xa;        return true&#xa;    elseif type(openType) == &quot;number&quot; then&#xa;        depotBoxName, depotBoxId = getdepotboxnamefromindex(openType), getdepotboxidfromindex(openType)&#xa;&#xa;        if getcontainer(depotBoxName) then&#xa;            return true&#xa;        end&#xa;    end&#xa;&#xa;    local lockerPos, lockerSpot, lockerDist = nil, nil, math.huge&#xa;&#xa;    local lockers = { [3497] = 'n', [3499] = 's', [3498] = 'w', [3450] = 'e' }&#xa;    local tiles = gettiles()&#xa;    for _, tile in ipairs(tiles) do&#xa;        local tilePos = tile.position&#xa;        local posX, posY, posZ = tilePos.x, tilePos.y, tilePos.z&#xa;        for id, dir in pairs(lockers) do&#xa;            local spot = getdirposition(dir, tilePos)&#xa;            -- TODO: simplify logic when tilereachable works properly for non-walkable tiles&#xa;            if isitemontile(id, tile) and tilereachable(spot.x, spot.y, spot.z) then&#xa;                local posDist = math.abs(posX - posx()) + math.abs(posY - posy())&#xa;&#xa;                if posDist &lt; lockerDist then&#xa;                    lockerPos = tile.position&#xa;                    lockerSpot = spot&#xa;                    lockerDist = posDist&#xa;                    break&#xa;                end&#xa;            end&#xa;        end&#xa;    end&#xa;&#xa;    if lockerSpot and tilereachable(lockerSpot.x, lockerSpot.y, lockerSpot.z) then&#xa;        reachlocation(lockerSpot.x, lockerSpot.y, lockerSpot.z)&#xa;    else&#xa;        return false&#xa;    end&#xa;&#xa;    local openLockerTries = 0&#xa;    while not getcontainer(&quot;locker&quot;) and openLockerTries &lt; 5 do&#xa;        if math.abs(lockerPos.x - posx()) > 1 or math.abs(lockerPos.y - posy()) > 1 then&#xa;            break&#xa;        end&#xa;&#xa;        local topUseId = topuseitem(lockerPos).id&#xa;&#xa;        useobject(lockerPos, topUseId, 0, 0xFF)&#xa;        wait(1300, 2000)&#xa;&#xa;        openLockerTries = openLockerTries + 1&#xa;    end&#xa;&#xa;    local lockerContainer = getcontainer(&quot;locker&quot;)&#xa;    if not lockerContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if openType == &quot;locker&quot; then&#xa;        return true&#xa;    end&#xa;&#xa;    local depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;    local openChestTries, depotChestId = 0, 3502&#xa;    while lockerContainer and not depotChestContainer and openChestTries &lt; 5 do&#xa;        openobject(depotChestId, &quot;locker&quot;)&#xa;        wait(1300, 2000)&#xa;&#xa;        lockerContainer = getcontainer(&quot;locker&quot;)&#xa;        depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;        openChestTries = openChestTries + 1&#xa;    end&#xa;&#xa;    if not depotChestContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    if openType == &quot;depot&quot; then&#xa;        return true&#xa;    end&#xa;&#xa;    local depotBoxContainer = getcontainer(depotBoxName)&#xa;    local openBoxTries = 0&#xa;    while depotChestContainer and not depotBoxContainer and openBoxTries &lt; 5 do&#xa;        openobject(depotBoxId, &quot;depot chest&quot;)&#xa;        wait(1300, 2000)&#xa;&#xa;        depotChestContainer = getcontainer(&quot;depot chest&quot;)&#xa;        depotBoxContainer = getcontainer(depotBoxName)&#xa;        openBoxTries = openBoxTries + 1&#xa;    end&#xa;&#xa;    return depotBoxContainer ~= nil and depotBoxContainer.name == depotBoxName&#xa;end&#xa;&#xa;--- closes all visible containers&#xa;--- @author  mistgun&#xa;function closecontainers()&#xa;    local containers = getcontainers()&#xa;&#xa;    while #containers > 0 do&#xa;        for _, cont in ipairs(containers) do&#xa;            closecontainer(cont.id)&#xa;            waitping()&#xa;        end&#xa;&#xa;        containers = getcontainers()&#xa;    end&#xa;end&#xa;&#xa;--- reopens backpacks specified&#xa;--- @author  mistgun&#xa;--- @param&#x9; ... table The backpacks list as {id, locationName, asNew}.&#xa;--- @return  boolean&#xa;function reopenbps(...)&#xa;    local bps = { ... }&#xa;&#xa;    closecontainers()&#xa;    waitping()&#xa;&#xa;    for _, bp in ipairs(bps) do&#xa;        openobject(bp[1], bp[2], bp[3])&#xa;        wait(500, 800)&#xa;    end&#xa;end&#xa;&#xa;--- puts items from given backpack to desired depot boxes&#xa;--- @author  mistgun&#xa;--- @param   fromBpName string name of the bp inside a main backpack from which the items will be deposited&#xa;--- @param   stackBoxIndex number index of the depot box where stackable items will be deposited (defaults to 1)&#xa;--- @param   nonStackBoxIndex number index of the depot box where non-stackable items will be deposited (defaults to 1)&#xa;--- @return  boolean&#xa;function deposititems(fromBpName, stackBoxIndex, nonStackBoxIndex)&#xa;    stackBoxIndex = stackBoxIndex or 1&#xa;    nonStackBoxIndex = nonStackBoxIndex or stackBoxIndex&#xa;&#xa;    local lootBpContainer, depotContainer = getcontainer(fromBpName), getcontainer(&quot;depot chest&quot;)&#xa;    if not lootBpContainer or not depotContainer then&#xa;        return false&#xa;    end&#xa;&#xa;    local function getFirstMatchingStorableItem()&#xa;        for index, item in ipairs(lootBpContainer.items) do&#xa;            local boxIndex = itemproperty(item.id, ITEM_CUMULATIVE) and stackBoxIndex or nonStackBoxIndex&#xa;            boxIndex = boxIndex - 1&#xa;&#xa;            local itemCount, itemStackPos = item.count == 0 and 1 or item.count, index - 1&#xa;&#xa;            if item.id ~= lootBpContainer.item.id and itemCount > 0 then&#xa;                local position = Position:new(0xffff, 0x40 + lootBpContainer.id, itemStackPos)&#xa;                local destPosition = Position:new(0xffff, 0x40 + depotContainer.id, boxIndex)&#xa;&#xa;                return position, item.id, itemStackPos, destPosition, itemCount&#xa;            end&#xa;        end&#xa;&#xa;        return nil&#xa;    end&#xa;&#xa;    while lootBpContainer and #lootBpContainer.items > 0 do&#xa;        lootBpContainer = getcontainer(fromBpName)&#xa;&#xa;        local position, itemID, itemStackPos, destPosition, itemCount = getFirstMatchingStorableItem()&#xa;&#xa;        local nextLootBpItemIndex = -1&#xa;        if not itemID then&#xa;            nextLootBpItemIndex = finditemindex(lootBpContainer.items, lootBpContainer.item.id)&#xa;&#xa;            if nextLootBpItemIndex == -1 then&#xa;                return true&#xa;            end&#xa;        end&#xa;&#xa;        if nextLootBpItemIndex ~= -1 then&#xa;            openobject(lootBpContainer.item.id, fromBpName, false, lootBpContainer.id + 1, nextLootBpItemIndex + 1)&#xa;            waitping()&#xa;        elseif itemID then&#xa;            moveobject(position, itemID, itemStackPos, destPosition, itemCount)&#xa;            waitping()&#xa;        end&#xa;    end&#xa;&#xa;    return true&#xa;end&#xa;&#xa;--[[&#xa;Extensions&#xa;--]]&#xa;&#xa;--- checks if given element exists in the table&#xa;--- @author  spec8320&#xa;--- @param   table any[]&#xa;--- @param   element any&#xa;--- @return  boolean&#xa;function table.contains(table, element)&#xa;    for _, value in pairs(table) do&#xa;        if value == element then&#xa;            return true&#xa;        end&#xa;    end&#xa;    return false&#xa;end&#xa;&#xa;--- removes nil values from the table&#xa;--- @author  mistgun&#xa;--- @return nil&#xa;function table.compact(self)&#xa;    for i = #self, 1, -1 do&#xa;        if self[i] == nil then&#xa;            table.remove(self, i)&#xa;        end&#xa;    end&#xa;end&#xa;&#xa;--- randomizes the elements in the table&#xa;--- @author  mistgun&#xa;--- @return  nil&#xa;function table.shuffle(self)&#xa;    local index&#xa;    for i = #self, 1, -1 do&#xa;        index = math.random(i)&#xa;&#xa;        self[i], self[index] = self[index], self[i]&#xa;    end&#xa;end&#xa;&#xa;--- split token string with delimiter&#xa;--- @author spec8320&#xa;--- @return string&#xa;function string:token(n, delimiter)&#xa;    delimiter = delimiter or &quot; +&quot;&#xa;    local result = {}&#xa;    local from = 1&#xa;    local delim_from, delim_to = self:find(delimiter, from)&#xa;    while delim_from do&#xa;        table.insert(result, self:sub(from, delim_from - 1))&#xa;        from = delim_to + 1&#xa;        delim_from, delim_to = self:find(delimiter, from)&#xa;    end&#xa;    table.insert(result, self:sub(from))&#xa;    if n then&#xa;        return result[n]&#xa;    end&#xa;    return result&#xa;end&#xa;&#xa;talk(12, &quot;hi&quot;)&#xa;waitping()&#xa;talk(12, &quot;trade&quot;)&#xa;waitping()&#xa;talk(12, &quot;potions&quot;)&#xa;waitping()&#xa;sellobject(285,countitems(285))&#xa;waitping()&#xa;buyitemsupto(266, 15)&#xa;waitping()&#xa;buyitemsupto(268, 200)&#xa;" label="manashop" type="Action" x="33910" y="31513" z="7"/>
            <Waypoint action="" type="Node" x="33900" y="31498" z="7"/>
            <Waypoint action="" label="BeforeShell" type="Stand" x="33917" y="31472" z="7"/>
			<Waypoint action="--- Check supply &#xa;if countitems(268) &lt; 200 then&#xa;gotolabel(&quot;depo&quot;)&#xa;else&#xa;gotolabel(&quot;goexp&quot;)&#xa;end" label="checksuply" type="Action" x="33917" y="31472" z="7"/>
            <Waypoint action="" label="UseShell" type="Use" x="33917" y="31471" z="7"/>
            
			<Waypoint action="" label="#goexp" type="Stand" x="33916" y="31459" z="8"/>
            <Waypoint action="" type="Node" x="32910" y="33435" z="8"/>
            <Waypoint action="" type="Node" x="32902" y="31420" z="8"/>
			
            <Waypoint action="" label="hunt" type="Node" x="32884" y="31426" z="8"/>


            <Waypoint action="--- Check Refil&#xa;local captoleave = 4000&#xa;local mp = 268&#xa;local mptoleave = 100&#xa;local hp = 266&#xa;local hptoleave = 5&#xa;--check medicine pouches&#xa;local checkItem = true&#xa;local item = countitems(12308)&#xa;local itemtoleave = 1&#xa;&#xa;dropitems(285,countitems(285))&#xa;wait(50)&#xa;if cap() &lt;= captoleave or countitems(mp) &lt;= mptoleave or countitems(hp) &lt;= hptoleave or (checkItem and item >= itemtoleave) then&#xa;gotolabel(&quot;refil&quot;)&#xa;else&#xa;gotolabel(&quot;hunt&quot;)&#xa;&#xa;end" type="Action" x="32749" y="31293" z="7"/>
            
			<Waypoint action="" label="gorefil" type="Stand" x="32910" y="31433" z="8"/>
            <Waypoint action="" type="Stand" x="32917" y="31470" z="8"/>
			<Waypoint action="" type="Rope" x="32917" y="31470" z="8"/>
            <Waypoint action="" type="Stand" x="32917" y="31478" z="7"/>
        </Waypoints>
        <SpecialAreas/>
        <Looting/>
    </CaveBot>
    <Scripts>
        <Hotkeys/>
        <Persistences>
            <Persistence label="">
                <Script content="auto(30000)&#xa;local position = getitempositionfromcontainers(3725)&#xa;useobject(position, 3725, position.z, 0)"></Script>
                <Enabled>Yes</Enabled>
            </Persistence>
        </Persistences>
    </Scripts>
    <Targeting>
        <TargetRules>
            <TargetRule label="">
                <Name>Exotic Bat</Name>
                <Count>0</Count>
                <MustAttackMe>No</MustAttackMe>
                <Settings>
                    <Settings1>
                        <HealthRange max="100" min="0" type="%"></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>Approach</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings1>
                    <Settings2>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings2>
                    <Settings3>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings3>
                    <Settings4>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings4>
                </Settings>
            </TargetRule>
            <TargetRule label="">
                <Name>elf, elf arcanist, elf scout</Name>
                <Count>0</Count>
                <MustAttackMe>No</MustAttackMe>
                <Settings>
                    <Settings1>
                        <HealthRange max="100" min="0" type="%"></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>Approach</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell>Whirlwind Throw</FirstSpell>
                        <SecondSpell>Brutal Strike</SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings1>
                    <Settings2>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings2>
                    <Settings3>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings3>
                    <Settings4>
                        <HealthRange max="0" min="0" type=""></HealthRange>
                        <AttackMode></AttackMode>
                        <AttackAvoidance></AttackAvoidance>
                        <DesiredStance>NoStance</DesiredStance>
                        <DesiredDistance></DesiredDistance>
                        <FirstSpell></FirstSpell>
                        <SecondSpell></SecondSpell>
                        <ThirdSpell></ThirdSpell>
                        <FourthSpell></FourthSpell>
                        <LureSpell></LureSpell>
                    </Settings4>
                </Settings>
            </TargetRule>
        </TargetRules>
    </Targeting>
</HoGSettings>
